<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">

    <!-- Favicon -->
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png">
    <link rel="manifest" href="/assets/images/site.webmanifest">
    <link rel="mask-icon" href="/assets/images/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">


    <title>「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java | Loda</title>

    <!-- Begin Jekyll SEO tag v2.6.0 -->
<title>「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java | Loda</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java" />
<meta name="author" content="loda" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hướng dẫn các bạn sử dụng biến, các kiểu dữ liệu trong java" />
<meta property="og:description" content="Hướng dẫn các bạn sử dụng biến, các kiểu dữ liệu trong java" />
<link rel="canonical" href="https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" />
<meta property="og:url" content="https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" />
<meta property="og:site_name" content="Loda" />
<meta property="og:image" content="https://loda.me/assets/images/loda1553050622971/1.jpg" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-20T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"Hướng dẫn các bạn sử dụng biến, các kiểu dữ liệu trong java","author":{"@type":"Person","name":"loda"},"@type":"BlogPosting","url":"https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/","publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://loda.me/assets/images/logo.png"},"name":"loda"},"image":"https://loda.me/assets/images/loda1553050622971/1.jpg","headline":"「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java","dateModified":"2019-03-20T00:00:00+00:00","datePublished":"2019-03-20T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/logo.png">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="/assets/css/fontawesome/css/all.css">

    <!-- Google Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet">

    <!-- Bootstrap Modified -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <!-- Theme Stylesheet -->
    <link rel="stylesheet" href="/assets/css/theme.css">


    <link href="/assets/css/syntax.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/css/loda.css">


    <!-- Jquery on header to make sure everything works, the rest  of the scripts in footer for fast loading -->
    <script src="/assets/js/jquery-3.3.1.min.js"></script>

    <!-- This goes before </head> closing tag, Google Analytics can be placed here --> 


</head>

<body class="">
    
    
<!-- change your GA id in _config.yml -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-135687402-1"
>
  let _namnh_enviroment = 'production';
  let _namnh_ga = true;
</script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-135687402-1");
</script>

<!-- Google Adsense -->
<script
  async
  src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"
></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-4098449502417396",
    enable_page_level_ads: true
  });
</script>



<!-- Facebook -->
<!-- FACEBOOK PLUGIN -->
<div id="fb-root"></div>
<script
  async
  defer
  crossorigin="anonymous"
  src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.2&appId=2157004821059773&autoLogAppEvents=1"
></script>

<!-- GOOGLE STRUCTURE DATA. FOR SEO
<script type="application/ld+json">
  {
    "@context": "https://schema.org/",
    "@type": "Book",
    "name": "「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java",
    "description": "Hướng dẫn các bạn sử dụng biến, các kiểu dữ liệu trong java",
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "",
      "bestRating": "100",
      "ratingCount": "2"
    }
  }
</script> -->
        

    <!-- Navbar -->
    <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top">
    <div class="container">
        <a class="navbar-brand loda-logo" href="/"><strong>Loda</strong></a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarColor02" style="">
            <ul class="navbar-nav mr-auto d-flex align-items-center">
               
    </li>

    <li class="nav-item">
      
      <a class="nav-link" href="/">Home</a>
    </li>
    <!-- End Blog -->

    <!-- Java -->
    
    </li>

    <li class="nav-item">
      
      <a class="nav-link" href="/java">Java</a>
    </li>
    <!-- End Java -->

    <!--Spring boot -->
    
    </li>

    <li class="nav-item">
      
      <a class="nav-link" href="/spring-boot">Spring Boot</a>
    </li>
    <!-- End Spring boot -->


    <!-- Machine learning -->
    
    </li>

    <li class="nav-item">
      
      <a class="nav-link" href="/machine-learning">Machine learning</a>
    </li>
    <!-- End Machine learning -->

    <!-- Subscription -->
    
    </li>

    <li class="nav-item">
      
      <a class="nav-link" href="/support">Yêu cầu bài viết</a>
    </li>
    <!-- End Python -->

    <!-- About -->
    
    </li>

    <li class="nav-item">
      
      <a class="nav-link" href="/about">About</a>
    </li>
    <!-- End About -->

    <!-- JetBrains -->
    
    </li>

    <li class="nav-item">
      
      <a class="btn btn-outline-success" href="/jetbrains">JetBrains Key</a>
    </li>
    <!-- <li class="nav-item">
      <a class="nav-link" href="#">Demo</a>
      <ul class="sub-menu">
        <li class="nav-item">
          <a class="nav-link nav-link__item" href="#">Demo 1</a>
          <div class="sub-menu">
            <ul class="sub-menu">
              <li class="nav-item">
                <a class="nav-link nav-link__item" href="#">Demo 1</a>
              </li>
            </ul>
          </div>
        </li>
      </ul>
    </li> -->

    <!-- <div class="dropdown menu">
      <a class="nav-link dropdown-toggle" 
         id="#navLink" 
         data-toggle="dropdown" 
         aria-haspopup="true" 
         aria-expanded="false">
        Menu
      </a>
      <ul class="sub-menu__item dropdown-menu" aria-labelledby="navLink">
        <li class="nav-item">
            <a class="nav-link dropdown-item" href="#">Action</a>
            <ul class="sub-menu" aria-labelledby="navLink">
                <li class="nav-item">
                    <a class="nav-link" href="#">Action 1</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Action 1</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Action 1</a>
                </li>
            </ul>
        </li>
        <li class="nav-item">
            <a class="nav-link dropdown-item" href="#">Action</a>
            <ul class="sub-menu" aria-labelledby="navLink">
                <li class="nav-item">
                    <a class="nav-link" href="#">Action 1</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Action 1</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">Action 1</a>
                </li>
            </ul>
        </li>
        <li class="nav-item">
            <a class="nav-link dropdown-item" href="#">Action</a>
        </li>
      </div>
    </div> -->

            </ul>
            <ul class="navbar-nav ml-auto d-flex align-items-center">
                <script src="/assets/js/lunr.js"></script>

<script>
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 1000 );
        $( "body" ).removeClass( "modal-open" );
    });
});
    

var documents = [{
    "id": 0,
    "url": "https://loda.me/404",
    "title": "404",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "https://loda.me/about",
    "title": "About",
    "body": "   Cảm ơn bạn đã ghé thăm.     Loda là blog chia sẻ về công nghệ, lập trình và  học máy được thành lập vào ngày 8/3/2019. Với tiêu chí xây dựng một trang  web blog chuyên nghiệp, lấy chất lượng làm đầu, tôi không  ngừng cố gắng từng ngày để đem đến cho các bạn đọc Việt Nam những kiến thức  mới và hay nhất.     Các bài viết tôi chia sẻ trên Loda sẽ đi từ  các kiến thức của một Software Engineer chứ không  phải dưới góc độ một Scientist. Vì thế tôi đề cao tính ứng dụng của  kiến thức, khả năng hiểu vấn đề và sử dụng của nó trong công việc của bạn.   Tuy vậy, không phải vì thế bài viết sơ sài, mà ngược lại còn rất chi tiết,  để bạn hiểu kiến thức từ bản chất.     Loda   luôn mong muốn nhận được sự giúp đỡ của các bạn để cải thiện chất lượng tốt  hơn.   Mọi thông tin xin hãy liên hệ:  Gmail: loda. namnh@gmail. com  GitHub：https://github. com/loda-kun  Nếu bạn muốn đăng lại các bài viết từ blog loda, xin tuân thủ:    1. Bạn có thể đăng lại bài viết hoặc một phần của bài viết. Khi bạn trích  dẫn vui lòng ghi rõ nguồn, bao gồm liên kết (link) đến trang web này và ghi  rõ nguồn  loda. me      2. Các bài đăng lại phải là phi lợi nhuận. Nếu muốn đăng vì lợi nhuận xin  hỏi tác giả trước.     3. Nếu bạn sửa chữa nội dung bài viết, bao gồm thêm, bớt hoặc viết tiếp xin  liên hệ với tác giả.   Một lần nữa, tôi xin chân thành cảm ơn. "
    }, {
    "id": 2,
    "url": "https://loda.me/author-jane.html",
    "title": "Jane",
    "body": "                        {{page. title}} Follow:         {{ site. authors. jane. site }}         {{ site. authors. jane. bio }}                                   Posts by {{page. title}}:       {% assign posts = site. posts | where: author , jane  %}      {% for post in posts %}      {% include main-loop-card. html %}      {% endfor %}  "
    }, {
    "id": 3,
    "url": "https://loda.me/author-sal.html",
    "title": "Sal",
    "body": "                        {{page. title}} Follow:         {{ site. authors. sal. site }}         {{ site. authors. sal. bio }}                                   Posts by {{page. title}}:       {% assign posts = site. posts | where: author , sal  %}      {% for post in posts %}      {% include main-loop-card. html %}      {% endfor %}  "
    }, {
    "id": 4,
    "url": "https://loda.me/authors-list.html",
    "title": "Authors",
    "body": "{{page. title}}:     {% for author in site. authors %}                                         {{ author[1]. name }} :       (View Posts)      {{ author[1]. bio }}                          &nbsp;       &nbsp;                                    {% endfor %}  "
    }, {
    "id": 5,
    "url": "https://loda.me/buy-me-a-coffee.html",
    "title": "Buy me a coffee",
    "body": "Hi! I am Sal, web designer &amp; developer at WowThemes. net. The free items I create are my side projects and Mundana for Jekyll is one of them. You can find all the work I release for free here. You have my permission to use the free items I develop in your personal, commercial or client projects. If you’d like to reward my work, I would be honored and I could dedicate more time maintaining the free projects. Thank you so much! Buy me a coffee "
    }, {
    "id": 6,
    "url": "https://loda.me/categories.html",
    "title": "Categories",
    "body": "          Categories          {% for category in site. categories %}     {{ category[0] }}:           {% assign pages_list = category[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "
    }, {
    "id": 7,
    "url": "https://loda.me/contact.html",
    "title": "Contact",
    "body": "   Please send your message to {{ site. name }}. We will reply as soon as  possible!                    "
    }, {
    "id": 8,
    "url": "https://loda.me/en/jetbrains",
    "title": "License key for Jetbrains IntelliJ IDEA 2019 (Updated)(Work 100%)",
    "body": "                    Share License Key to activate copyright for products in the ecosystem of Jetbrains. You can activate the products below:                         Note::               The license belongs to the lanyu and the article only wishes to share it with the community, not        encouraging free use.                               loda. me         will not be responsible for individuals using the provided key                     If available, purchase products at:                  https://www. jetbrains. com/idea/buy/                     Get key:                       I have read and accepted                Get Key                   How to use:       1. Edit hosts file      Open hosts             Windows:                                                   1                                      C:\Windows\System32\drivers\etc\hosts                                                  Linux/Mac:                                                         1                                      /etc/hosts                                          Append this line to the last of the hosts file                                                   1                                      0. 0. 0. 0 account. jetbrains. com                                          Don't forget source /etc/host       2. Add key      Open your JetBrains product       Help &gt; Register. . .       Put the code to the Activation code and OK                   Activation code work for                         Key IntelliJ IDEA Ultimate / Activation Code IntelliJ IDEA Ultimate                           Key ReSharper Ultimate / Activation Code ReSharper Ultimate                           Key Rider / Activation Code Rider                           Key GoLand / Activation Code GoLand                           Key AppCode / Activation Code AppCode                           Key CLion / Activation Code CLion                           Key PyCharm Professional / Activation Code PyCharm Professional                           Key WebStorm / Activation Code WebStorm                           Key RubyMine / Activation Code RubyMine                                 Tặng tôi 1 cốc coffee      Cảm ơn bạn đã theo dõi Loda,        ủng hộ của bạn kèm theo phản hồi sẽ giúp loda        cải thiện thêm chất lượng bài viết.       Buy me a        coffee                                            JetBrains Activation Code           &times;                          56ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==                          Close                    "
    }, {
    "id": 9,
    "url": "https://loda.me/jetbrains",
    "title": "License Key Jetbrains IntelliJ IDEA cập nhật 2019 (Hoạt động 100%)",
    "body": "                    Click here for English version                    Chia sẻ License key kích hoạt bản quyền cho các sản phẩm        trong hệ sinh thái của Jetbrains. Bạn có thể kích hoạt các sản        phẩm dưới đây:                         Lưu ý::               License thuộc về tác giả lanyu và bài viết chỉ mong muốn        chia sẻ cho cộng đồng, chứ không khuyến khích việc sử dụng miễn phí.                     Nếu có điều kiện, hãy mua sản phẩm chính hãng:                  https://www. jetbrains. com/idea/buy/                 Ủng hộ nhà sản xuất cũng như được hỗ trợ các tính năng mới        nhất!             Lấy key:       Key chỉ hoạt dộng trên các version trước 2019. 1       Thời hạn Key: 11/03/2020                       Tôi đã đọc và hiểu những lưu ý ở trên.                 Get Key                   Cách cài đặt:       1. Sửa hosts      Mở file hosts             Windows:      Bạn nên sử dụng Notepad++ để edit. Nếu không, hãy copy file hosts ra một nơi khác, chỉnh sửa, rồi copy đè lại hosts cũ                                                  1                                      C:\Windows\System32\drivers\etc\hosts                                                  Linux/Mac:            Sử dụng quyền sudo để edit bạn nhé.                                                   1                                      /etc/hosts                                          Thêm vào dòng cuối cùng của file hosts và lưu lại                                                   1                                      0. 0. 0. 0 account. jetbrains. com                                          Lưu ý, nếu bạn sử dụng Linux hay Mac: source /etc/hosts để thay đổi có hiệu lực       2. Nhập key      Mở sản phẩm của JetBrains bạn đang sử dụng       Help &gt; Register. . .       Nhập key vào Activation code và OK                   Key hoạt động với các sản phẩm dưới đây                         Key IntelliJ IDEA Ultimate / Activation Code IntelliJ IDEA Ultimate                           Key ReSharper Ultimate / Activation Code ReSharper Ultimate                           Key Rider / Activation Code Rider                           Key GoLand / Activation Code GoLand                           Key AppCode / Activation Code AppCode                           Key CLion / Activation Code CLion                           Key PyCharm Professional / Activation Code PyCharm Professional                           Key WebStorm / Activation Code WebStorm                           Key RubyMine / Activation Code RubyMine                                 Tặng tôi 1 cốc coffee      Cảm ơn bạn đã theo dõi Loda,        ủng hộ của bạn kèm theo phản hồi sẽ giúp loda        cải thiện thêm chất lượng bài viết.       Buy me a        coffee                                            JetBrains Activation Code           &times;                          56ZS5PQ1RF-eyJsaWNlbnNlSWQiOiI1NlpTNVBRMVJGIiwibGljZW5zZWVOYW1lIjoi5q2j54mI5o6I5p2DIC4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAzLTEwIn0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDMtMTAifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMy0xMCJ9XSwiaGFzaCI6IjEyMjkxNDk4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-SYSsDcgL1WJmHnsiGaHUWbaZLPIe2oI3QiIneDtaIbh/SZOqu63G7RGudSjf3ssPb1zxroMti/bK9II1ugHz/nTjw31Uah7D0HqeaCO7Zc0q9BeHysiWmBZ+8bABs5vr25GgIa5pO7CJhL7RitXQbWpAajrMBAeZ2En3wCgNwT6D6hNmiMlhXsWgwkw2OKnyHZ2dl8yEL+oV5SW14t7bdjYGKQrYjSd4+2zc4FnaX88yLnGNO9B3U6G+BuM37pxS5MjHrkHqMTK8W3I66mIj6IB6dYXD5nvKKO1OZREBAr6LV0BqRYSbuJKFhZ8nd6YDG20GvW6leimv0rHVBFmA0w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==                          Close                    "
    }, {
    "id": 10,
    "url": "https://loda.me/privacy-policy.html",
    "title": "Privacy Policy",
    "body": "”{{site. name}}” takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor’s preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google’s cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "
    }, {
    "id": 11,
    "url": "https://loda.me/support",
    "title": "Yêu cầu bài viết",
    "body": "Xin chào các bạn, mình là loda, blog của mình hướng tới chia sẻ các kiến thức về Java nâng cao, và thuần túy cho người Việt. Hiện tại blog đang trong quá trình xây dựng, nên còn thiếu rất rất nhiều nội dung, tuy nhiên hãy cho mình biết bạn muốn học gì nhất vào thời điểm này, mình sẽ ưu tiên viết về nó trước tiên, với tiêu chí là chi tiết, đúng bản chất nhưng phải dễ hiểu :D  cảm ơn bạn!   * indicates required	Email Address *		Nội dung muốn tìm hiểu *							        "
    }, {
    "id": 12,
    "url": "https://loda.me/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 13,
    "url": "https://loda.me/index.html",
    "title": "Loda - develop your own style",
    "body": "      {% assign latest_post = site. posts[0] %}          &lt;div style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                        {% for recent_post in site. posts offset:1 limit:3 %}                  {% if recent_post. image %}                    &lt;img class= w-100  src= {% if recent_post. image contains  ://  %}{{ recent_post. image }}{% else %}{{site. baseurl}}/{{ recent_post. image }}{% endif %}  alt= {{ recent_post. title }} &gt;                  {% endif %}                              {{ recent_post. title }}        :                   In           {% for category in recent_post. categories %}          {{ category }},           {% endfor %}                                              {{ recent_post. date | date: '%b %d, %Y' }}                      {% endfor %}            {% include home-highligh-box. html %}                  All Stories:     {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}        {% include bottom-bar-paginator. html %}          {% include sidebar-featured. html %}      "
    }, {
    "id": 14,
    "url": "https://loda.me/page/2/index.html",
    "title": "Loda - develop your own style - page 2",
    "body": "      {% assign latest_post = site. posts[0] %}          &lt;div style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                        {% for recent_post in site. posts offset:1 limit:3 %}                  {% if recent_post. image %}                    &lt;img class= w-100  src= {% if recent_post. image contains  ://  %}{{ recent_post. image }}{% else %}{{site. baseurl}}/{{ recent_post. image }}{% endif %}  alt= {{ recent_post. title }} &gt;                  {% endif %}                              {{ recent_post. title }}        :                   In           {% for category in recent_post. categories %}          {{ category }},           {% endfor %}                                              {{ recent_post. date | date: '%b %d, %Y' }}                      {% endfor %}            {% include home-highligh-box. html %}                  All Stories:     {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}        {% include bottom-bar-paginator. html %}          {% include sidebar-featured. html %}      "
    }, {
    "id": 15,
    "url": "https://loda.me/page/3/index.html",
    "title": "Loda - develop your own style - page 3",
    "body": "      {% assign latest_post = site. posts[0] %}          &lt;div style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                        {% for recent_post in site. posts offset:1 limit:3 %}                  {% if recent_post. image %}                    &lt;img class= w-100  src= {% if recent_post. image contains  ://  %}{{ recent_post. image }}{% else %}{{site. baseurl}}/{{ recent_post. image }}{% endif %}  alt= {{ recent_post. title }} &gt;                  {% endif %}                              {{ recent_post. title }}        :                   In           {% for category in recent_post. categories %}          {{ category }},           {% endfor %}                                              {{ recent_post. date | date: '%b %d, %Y' }}                      {% endfor %}            {% include home-highligh-box. html %}                  All Stories:     {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}        {% include bottom-bar-paginator. html %}          {% include sidebar-featured. html %}      "
    }, {
    "id": 16,
    "url": "https://loda.me/page/4/index.html",
    "title": "Loda - develop your own style - page 4",
    "body": "      {% assign latest_post = site. posts[0] %}          &lt;div style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                        {% for recent_post in site. posts offset:1 limit:3 %}                  {% if recent_post. image %}                    &lt;img class= w-100  src= {% if recent_post. image contains  ://  %}{{ recent_post. image }}{% else %}{{site. baseurl}}/{{ recent_post. image }}{% endif %}  alt= {{ recent_post. title }} &gt;                  {% endif %}                              {{ recent_post. title }}        :                   In           {% for category in recent_post. categories %}          {{ category }},           {% endfor %}                                              {{ recent_post. date | date: '%b %d, %Y' }}                      {% endfor %}            {% include home-highligh-box. html %}                  All Stories:     {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}        {% include bottom-bar-paginator. html %}          {% include sidebar-featured. html %}      "
    }, {
    "id": 17,
    "url": "https://loda.me/page/5/index.html",
    "title": "Loda - develop your own style - page 5",
    "body": "      {% assign latest_post = site. posts[0] %}          &lt;div style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                        {% for recent_post in site. posts offset:1 limit:3 %}                  {% if recent_post. image %}                    &lt;img class= w-100  src= {% if recent_post. image contains  ://  %}{{ recent_post. image }}{% else %}{{site. baseurl}}/{{ recent_post. image }}{% endif %}  alt= {{ recent_post. title }} &gt;                  {% endif %}                              {{ recent_post. title }}        :                   In           {% for category in recent_post. categories %}          {{ category }},           {% endfor %}                                              {{ recent_post. date | date: '%b %d, %Y' }}                      {% endfor %}            {% include home-highligh-box. html %}                  All Stories:     {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}        {% include bottom-bar-paginator. html %}          {% include sidebar-featured. html %}      "
    }, {
    "id": 18,
    "url": "https://loda.me/java/index.html",
    "title": "Java",
    "body": ""
    }, {
    "id": 19,
    "url": "https://loda.me/java/page/2/index.html",
    "title": "Java - page 2",
    "body": ""
    }, {
    "id": 20,
    "url": "https://loda.me/java/page/3/index.html",
    "title": "Java - page 3",
    "body": ""
    }, {
    "id": 21,
    "url": "https://loda.me/machine-learning/index.html",
    "title": "Machine Learning",
    "body": ""
    }, {
    "id": 22,
    "url": "https://loda.me/machine-learning/page/2/index.html",
    "title": "Machine Learning - page 2",
    "body": ""
    }, {
    "id": 23,
    "url": "https://loda.me/python/index.html",
    "title": "Python",
    "body": ""
    }, {
    "id": 24,
    "url": "https://loda.me/spring-boot/index.html",
    "title": "Spring Boot",
    "body": ""
    }, {
    "id": 25,
    "url": "https://loda.me/spring-boot/page/2/index.html",
    "title": "Spring Boot - page 2",
    "body": ""
    }, {
    "id": 26,
    "url": "https://loda.me/Huong-dan-@OneToMany-va-@ManyToOne/",
    "title": "「Jpa」Hướng dẫn @OneToMany và @ManyToOne",
    "body": "2019/04/06 - Cách biểu thị quan hệ 1-n trong cơ sở dữ liệu là rất phổ biến, ví dụ một địa chỉ có thể có nhiều người ở (gia đình). Bình thường, khi các bạn tạo table trong csdl để biểu thị mối quan hệ này, thì bảng đại diện phía nhiều (phía n trong câu 1-n) sẽ chứa id của bảng tham chiếu (phía 1 trong câu 1-n) Thể hiện mỗi quan hệ này một cách đầy đủ trong code bằng Hibernate thì chúng ta sẽ dùng @OneToMany và @ManyToOne. Trong bài sử dụng các kiến thức:  Hibernate là gì? Cách sử dụng Lombok để tiết kiệm thời gian codeTạo project: Toàn bộ bài viết được up tại Github: github. com/loda-kun/java-all Chúng ta sẽ sử dụng Gradle để tạo một project có khai báo Spring Boot và Jpa để hỗ trợ cho việc demo @ManyToOne. Các bạn có thể tự tạo 1 project Spring-boot với gradle đơn giản tại: https://start. spring. io plugins {  id 'org. springframework. boot' version '2. 1. 4. RELEASE'  id 'java'}apply plugin: 'io. spring. dependency-management'group 'me. loda. java'version '1. 0-SNAPSHOT'sourceCompatibility = 1. 8configurations {  compileOnly {    extendsFrom annotationProcessor  }}repositories {  mavenCentral()}dependencies {  implementation 'org. springframework. boot:spring-boot-starter-data-jpa'  implementation 'org. springframework. boot:spring-boot-starter-web'  compileOnly 'org. projectlombok:lombok'  runtimeOnly 'com. h2database:h2'  annotationProcessor 'org. projectlombok:lombok'  testImplementation 'org. springframework. boot:spring-boot-starter-test'}Trong ứng dụng trên bạn sẽ thấy có com. h2database:h2. Đây là một database, tuy nhiên nó chỉ tồn tại trong bộ nhớ. Tức làm mỗi khi chạy chương trình này, nó sẽ tạo database trong RAM, và tắt chương trình đi nó sẽ mất. Chúng ta sẽ sử dụng H2 thay cho MySql để cho. . tiện! Khi tạo xong project, sẽ có thư mục như sau: Tạo Table: Để tạo table, chúng ta tạo ra các Class tương ứng. import java. util. Collection;import javax. persistence. CascadeType;import javax. persistence. Entity;import javax. persistence. GeneratedValue;import javax. persistence. Id;import javax. persistence. OneToMany;import lombok. AllArgsConstructor;import lombok. Data;import lombok. EqualsAndHashCode;import lombok. NoArgsConstructor;import lombok. ToString;@Entity // Đánh dấu đây là table trong db@Data // lombok giúp generate các hàm constructor, get, set v. v. @AllArgsConstructor@NoArgsConstructorpublic class Address {  @Id //Đánh dấu là primary key  @GeneratedValue // Giúp tự động tăng  private Long id;  private String city;  private String province;  @OneToMany(mappedBy =  address , cascade = CascadeType. ALL) // Quan hệ 1-n với đối tượng ở dưới (Person) (1 địa điểm có nhiều người ở)  // MapopedBy trỏ tới tên biến Address ở trong Person.   @EqualsAndHashCode. Exclude // không sử dụng trường này trong equals và hashcode  @ToString. Exclude // Khoonhg sử dụng trong toString()  private Collection&lt;Person&gt; persons;}@Entity@Data@NoArgsConstructor@AllArgsConstructorpublic class Person {  @Id  @GeneratedValue  private Long id;  private String name;  // Many to One Có nhiều người ở 1 địa điểm.   @ManyToOne   @JoinColumn(name =  address_id ) // thông qua khóa ngoại address_id  @EqualsAndHashCode. Exclude  @ToString. Exclude  private Address address;}Nếu chúng ta chưa tạo ra các table trong cơ sở dữ liệu, thì mặc định Hibernate sẽ bind dữ liệu từ class xuống và tạo table cho chúng ta. Bạn phải tạo file config src\main\resources\application. properties như sau để kết nối tới H2 database nhé: spring. datasource. url=jdbc:h2:mem:testdbspring. datasource. driverClassName=org. h2. Driverspring. datasource. username=saspring. datasource. password=// Không có password, vào thẳng luônspring. jpa. database-platform=org. hibernate. dialect. H2Dialect# Cho phép vào xem db thông qua webspring. h2. console. enabled=trueChạy thử: Bạn tạo file OneToManyExampleApplication và cấu hình Spring Boot và khởi chạy chương trình. @SpringBootApplication@RequiredArgsConstructorpublic class OneToManyExampleApplication {  public static void main(String[] args) {    SpringApplication. run(OneToManyExampleApplication. class, args);  }}Sau khi chạy xong, hãy truy cập vào http://localhost:8080/h2-console/ để vào xem database có gì nhé.  Bạn sẽ thấy nó tạo table giống với mô tả ở đầu bài. Với khóa ngoại address_id ở bảng person. Thêm dữ liệu: Để thêm dữ liệu vào database, chúng ta sẽ dùng tới Spring JPA . import org. springframework. data. jpa. repository. JpaRepository;public interface AddressRepository extends JpaRepository&lt;Address,Long&gt; {}public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {}Chúng ta sẽ tạo một chương trình Spring Boot đơn giản bằng cách sử dụng CommandLineRunner để chạy code ngay khi khởi động. import javax. transaction. Transactional;import org. springframework. boot. CommandLineRunner;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;import com. google. common. collect. Lists;import lombok. RequiredArgsConstructor;@SpringBootApplication@RequiredArgsConstructorpublic class OneToManyExampleApplication implements CommandLineRunner {  public static void main(String[] args) {    SpringApplication. run(OneToManyExampleApplication. class, args);  }  // Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired  private final PersonRepository personRepository;  private final AddressRepository addressRepository;  @Override  public void run(String. . . args) throws Exception {    // Tạo ra đối tượng Address có tham chiếu tới person    Address address = new Address();    address. setCity( Hanoi );    // Tạo ra đối tượng person    Person person = new Person();    person. setName( loda );    person. setAddress(address);    address. setPersons(Collections. singleton(person));    // Lưu vào db    // Chúng ta chỉ cần lưu address, vì cascade = CascadeType. ALL nên nó sẽ lưu luôn Person.     addressRepository. saveAndFlush(address);    // Vào: http://localhost:8080/h2-console/ để xem dữ liệu đã insert    personRepository. findAll(). forEach(p -&gt; {      System. out. println(p. getId());      System. out. println(p. getName());      System. out. println(p. getAddress());    });  }}//output: // 2// loda// Address(id=1, city=Hanoi, province=null)// Chúng ta đã có thể gọi trực tiếp address trong person sau khi queryKết quả trong database lúc này: Bài viết của mình không còn gì để ngắn hơn được nữa :((( thật hổ thẹn, mình có up code lên đây, bạn chạy code cái là hiểu liền à: github. com/loda-kun/java-all Chúc các bạn học tập thật tốt! ahuu    Hướng dẫn sử dụng @OneToOne     Hướng dẫn sử dụng @ManyToMany  "
    }, {
    "id": 27,
    "url": "https://loda.me/Huong-dan-@ManyToMany/",
    "title": "「Jpa」Hướng dẫn @ManyToMany",
    "body": "2019/04/06 - Cách biểu thị quan hệ n-n trong cơ sở dữ liệu là rất phổ biến, ví dụ một địa chỉ có thể có nhiều người ở (gia đình). và một người có thể có nhiều hơn một địa chỉ. Bình thường, khi các bạn tạo table trong csdl để biểu thị mối quan hệ này, chúng ta sẽ tạo ra một bảng mới, tham chiếu tới cả bảng này.  Thể hiện mỗi quan hệ này một cách đầy đủ trong code bằng Hibernate thì chúng ta sẽ dùng @ManyToMany Trong bài sử dụng các kiến thức:  Hibernate là gì? Cách sử dụng Lombok để tiết kiệm thời gian codeTạo project: Toàn bộ bài viết được up tại Github: github. com/loda-kun/java-all Chúng ta sẽ sử dụng Gradle để tạo một project có khai báo Spring Boot và Jpa để hỗ trợ cho việc demo @ManyToMany. Các bạn có thể tự tạo 1 project Spring-boot với gradle đơn giản tại: https://start. spring. io plugins {  id 'org. springframework. boot' version '2. 1. 4. RELEASE'  id 'java'}apply plugin: 'io. spring. dependency-management'group 'me. loda. java'version '1. 0-SNAPSHOT'sourceCompatibility = 1. 8configurations {  compileOnly {    extendsFrom annotationProcessor  }}repositories {  mavenCentral()}dependencies {  implementation 'org. springframework. boot:spring-boot-starter-data-jpa'  implementation 'org. springframework. boot:spring-boot-starter-web'  compileOnly 'org. projectlombok:lombok'  runtimeOnly 'com. h2database:h2'  annotationProcessor 'org. projectlombok:lombok'  testImplementation 'org. springframework. boot:spring-boot-starter-test'}Trong ứng dụng trên bạn sẽ thấy có com. h2database:h2. Đây là một database, tuy nhiên nó chỉ tồn tại trong bộ nhớ. Tức làm mỗi khi chạy chương trình này, nó sẽ tạo database trong RAM, và tắt chương trình đi nó sẽ mất. Chúng ta sẽ sử dụng H2 thay cho MySql để cho. . tiện! Khi tạo xong project, sẽ có thư mục như sau: Tạo Table: Để tạo table, chúng ta tạo ra các Class tương ứng. import java. util. Collection;import javax. persistence. CascadeType;import javax. persistence. Entity;import javax. persistence. FetchType;import javax. persistence. GeneratedValue;import javax. persistence. Id;import javax. persistence. JoinColumn;import javax. persistence. JoinTable;import javax. persistence. ManyToMany;import lombok. AllArgsConstructor;import lombok. Builder;import lombok. Data;import lombok. EqualsAndHashCode;import lombok. NoArgsConstructor;import lombok. ToString;@Entity // Đánh dấu đây là table trong db@Data // lombok giúp generate các hàm constructor, get, set v. v. @AllArgsConstructor@NoArgsConstructor@Builderpublic class Address {  @Id //Đánh dấu là primary key  @GeneratedValue // Giúp tự động tăng  private Long id;  private String city;  private String province;  @ManyToMany(cascade = CascadeType. ALL, fetch = FetchType. LAZY)  // Quan hệ n-n với đối tượng ở dưới (Person) (1 địa điểm có nhiều người ở)  @EqualsAndHashCode. Exclude // không sử dụng trường này trong equals và hashcode  @ToString. Exclude // Khoonhg sử dụng trong toString()    @JoinTable(name =  address_person , //Tạo ra một join Table tên là  address_person       joinColumns = @JoinColumn(name =  address_id ), // TRong đó, khóa ngoại chính là address_id trỏ tới class hiện tại (Address)      inverseJoinColumns = @JoinColumn(name =  person_id ) //Khóa ngoại thứ 2 trỏ tới thuộc tính ở dưới (Person)  )  private Collection&lt;Person&gt; persons;}@Entity@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class Person {  @Id  @GeneratedValue  private Long id;  private String name;    // mappedBy trỏ tới tên biến persons ở trong Address.   @ManyToMany(mappedBy =  persons )  // LAZY để tránh việc truy xuất dữ liệu không cần thiết. Lúc nào cần thì mới query  @EqualsAndHashCode. Exclude  @Exclude  private Collection&lt;Address&gt; addresses;}Nếu chúng ta chưa tạo ra các table trong cơ sở dữ liệu, thì mặc định Hibernate sẽ bind dữ liệu từ class xuống và tạo table cho chúng ta. Bạn phải tạo file config src\main\resources\application. properties như sau để kết nối tới H2 database nhé: spring. datasource. url=jdbc:h2:mem:testdbspring. datasource. driverClassName=org. h2. Driverspring. datasource. username=saspring. datasource. password=// Không có password, vào thẳng luônspring. jpa. database-platform=org. hibernate. dialect. H2Dialect# Cho phép vào xem db thông qua webspring. h2. console. enabled=trueChạy thử: Bạn tạo file ManyToManyExampleApplication và cấu hình Spring Boot và khởi chạy chương trình. @SpringBootApplication@RequiredArgsConstructorpublic class ManyToManyExampleApplication {  public static void main(String[] args) {    SpringApplication. run(ManyToManyExampleApplication. class, args);  }}Sau khi chạy xong, hãy truy cập vào http://localhost:8080/h2-console/ để vào xem database có gì nhé.  Bạn sẽ thấy nó tạo table giống với mô tả ở đầu bài. Gồm có hai bảng chính là address và person. Ngoài ra, sẽ tạo ra một bảng trung gian ở giữa liên kết hai bảng là address_person. Thêm dữ liệu: Để thêm dữ liệu vào database, chúng ta sẽ dùng tới Spring JPA . import org. springframework. data. jpa. repository. JpaRepository;public interface AddressRepository extends JpaRepository&lt;Address,Long&gt; {}public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {}Chúng ta sẽ tạo một chương trình Spring Boot đơn giản bằng cách sử dụng CommandLineRunner để chạy code ngay khi khởi động. import javax. transaction. Transactional;import org. springframework. boot. CommandLineRunner;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;import com. google. common. collect. Lists;import lombok. RequiredArgsConstructor;@SpringBootApplication@RequiredArgsConstructorpublic class ManyToManyExampleApplication implements CommandLineRunner {  public static void main(String[] args) {    SpringApplication. run(ManyToManyExampleApplication. class, args);  }  // Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired  private final PersonRepository personRepository;  private final AddressRepository addressRepository;  @Override  @Transactional  public void run(String. . . args) throws Exception {    // Tạo ra đối tượng Address    Address hanoi = Address. builder()                 . city( hanoi )                 . build();    Address hatay = Address. builder()                . city( hatay )                . build();    // Tạo ra đối tượng person    Person person1 = Person. builder()               . name( loda1 )               . build();    Person person2 = Person. builder()               . name( loda2 )               . build();    // set Persons vào address    hanoi. setPersons(Lists. newArrayList(person1, person2));    hatay. setPersons(Lists. newArrayList(person1));    // Lưu vào db    // Chúng ta chỉ cần lưu address, vì cascade = CascadeType. ALL nên nó sẽ lưu luôn Person.     addressRepository. saveAndFlush(hanoi);    addressRepository. saveAndFlush(hatay);    // Vào: http://localhost:8080/h2-console/ để xem dữ liệu đã insert    Address queryResult = addressRepository. findById(1L). get();    System. out. println(queryResult. getCity());    System. out. println(queryResult. getPersons());  }}// Output:// hanoi// [Person(id=2, name=loda1), Person(id=3, name=loda2)]Lưu ý ở đây chúng ta dùng @Transactional. Đê khiến toàn bộ code chạy trong hàm đều nằm trong Session quản lý của Hibernate. Nếu không có @Transactional thì việc bạn gọi address. getPersons() sẽ bị lỗi, vì nó không thể query xuống database để lấy dữ liệu person lên được. Bạn ghi nhớ chỗ này nhé. Kết quả trong database lúc này: Address Person Address_Person Bài viết của mình không còn gì để ngắn hơn được nữa :((( thật hổ thẹn, mình có up code lên đây, bạn chạy code cái là hiểu liền à: github. com/loda-kun/java-all Chúc các bạn học tập thật tốt! ahuu    Hướng dẫn sử dụng @OneToOne     Hướng dẫn sử dụng @OneToMany và @ManyToOne  "
    }, {
    "id": 28,
    "url": "https://loda.me/Huong-dan-su-dung-@OneToOne-Relationship/",
    "title": "「Jpa」Hướng dẫn sử dụng @OneToOne",
    "body": "2019/04/05 - Cách biểu thị quan hệ 1-1 trong cơ sở dữ liệu là rất phổ biến, ví dụ một người sẽ có một địa chỉ duy nhất (giả sử). Bình thường, khi các bạn tạo table trong csdl để biểu thị mối quan hệ này, thì sẽ có một bảng chứa khóa ngoại của bảng còn lại.  Thể hiện mỗi quan hệ này trong code bằng Hibernate thì chúng ta sẽ dùng @OneToOne. Trong bài sử dụng các kiến thức:  Hibernate là gì? Cách sử dụng Lombok để tiết kiệm thời gian codeTạo project: Toàn bộ bài viết được up tại Github: github. com/loda-kun/java-all Chúng ta sẽ sử dụng Gradle để tạo một project có khai báo Spring Boot và Jpa để hỗ trợ cho việc demo @OneToOne. Các bạn có thể tự tạo 1 project Spring-boot với gradle đơn giản tại: https://start. spring. io plugins {  id 'org. springframework. boot' version '2. 1. 4. RELEASE'  id 'java'}apply plugin: 'io. spring. dependency-management'group 'me. loda. java'version '1. 0-SNAPSHOT'sourceCompatibility = 1. 8configurations {  compileOnly {    extendsFrom annotationProcessor  }}repositories {  mavenCentral()}dependencies {  implementation 'org. springframework. boot:spring-boot-starter-data-jpa'  implementation 'org. springframework. boot:spring-boot-starter-web'  compileOnly 'org. projectlombok:lombok'  runtimeOnly 'com. h2database:h2'  annotationProcessor 'org. projectlombok:lombok'  testImplementation 'org. springframework. boot:spring-boot-starter-test'}Trong ứng dụng trên bạn sẽ thấy có com. h2database:h2. Đây là một database, tuy nhiên nó chỉ tồn tại trong bộ nhớ. Tức làm mỗi khi chạy chương trình này, nó sẽ tạo database trong RAM, và tắt chương trình đi nó sẽ mất. Chúng ta sẽ sử dụng H2 thay cho MySql để cho. . tiện! Khi tạo xong project, sẽ có thư mục như sau: Tạo Table: Để tạo table, chúng ta tạo ra các Class tương ứng. import javax. persistence. Entity;import javax. persistence. GeneratedValue;import javax. persistence. Id;import javax. persistence. JoinColumn;import javax. persistence. OneToOne;import lombok. Builder;import lombok. Data;@Entity // Hibernate entity@Data // Lombok @Builder // Lombokpublic class Person { //Table person  @Id // Đánh dấu trường này là primary key  @GeneratedValue // Tự động tăng giá trị id  private Long id;  private String name;}@Entity@Data@Builderpublic class Address { // Table address  @Id  @GeneratedValue  private Long id;  private String city;  private String province;  @OneToOne // Đánh dấu có mỗi quan hệ 1-1 với Person ở phía dưới  @JoinColumn(name =  person_id ) // Liên kết với nhau qua khóa ngoại person_id  private Person person; }Nếu chúng ta chưa tạo ra các table trong cơ sở dữ liệu, thì mặc định Hibernate sẽ bind dữ liệu từ class xuống và tạo table cho chúng ta. Bạn phải tạo file config src\main\resources\application. properties như sau để kết nối tới H2 database nhé: spring. datasource. url=jdbc:h2:mem:testdbspring. datasource. driverClassName=org. h2. Driverspring. datasource. username=saspring. datasource. password=// Không có password, vào thẳng luônspring. jpa. database-platform=org. hibernate. dialect. H2Dialect# Cho phép vào xem db thông qua webspring. h2. console. enabled=trueChạy thử: Bạn tạo file OneToOneExampleApplication và cấu hình Spring Boot và khởi chạy chương trình. @SpringBootApplication@RequiredArgsConstructorpublic class OneToOneExampleApplication {  public static void main(String[] args) {    SpringApplication. run(OneToOneExampleApplication. class, args);  }}Sau khi chạy xong, hãy truy cập vào http://localhost:8080/h2-console/ để vào xem database có gì nhé.  Bạn sẽ thấy nó tạo table giống với mô tả ở đầu bài. Với khóa ngoại person_id ở bảng address. Thêm dữ liệu: Để thêm dữ liệu vào database, chúng ta sẽ dùng tới Jpa. import org. springframework. data. jpa. repository. JpaRepository;public interface AddressRepository extends JpaRepository&lt;Address,Long&gt; {}public interface PersonRepository extends JpaRepository&lt;Person, Long&gt; {}Chúng ta sẽ tạo một chương trình Spring Boot đơn giản bằng cách sử dụng CommandLineRunner để chạy code ngay khi khởi động. import javax. transaction. Transactional;import org. springframework. boot. CommandLineRunner;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;import com. google. common. collect. Lists;import lombok. RequiredArgsConstructor;@SpringBootApplication@RequiredArgsConstructorpublic class OneToOneExampleApplication implements CommandLineRunner {  public static void main(String[] args) {    SpringApplication. run(OneToOneExampleApplication. class, args);  }  // Sử dụng @RequiredArgsConstructor và final để thay cho @Autowired  private final PersonRepository personRepository;  private final AddressRepository addressRepository;  @Override  public void run(String. . . args) throws Exception {    // Tạo ra đối tượng person    Person person = Person. builder()               . name( loda )               . build();    // Lưu vào db    personRepository. save(person);    // Tạo ra đối tượng Address có tham chiếu tới person    Address address = Address. builder()        . city( Hanoi )        . person(person)        . build();    // Lưu vào db    addressRepository. save(address);    // Vào: http://localhost:8080/h2-console/ để xem dữ liệu đã insert  }}Kết quả trong database lúc này: Vậy là thằng Address đã liên kết tới Person có id=1. Đúng như ta mong đợi. Bài viết của mình không còn gì để ngắn hơn được nữa :((( thật hổ thẹn, mình có up code lên đây, bạn chạy code cái là hiểu liền à: github. com/loda-kun/java-all Chúc các bạn học tập tốt! ahuu  Hướng dẫn sử dụng @OneToMany Hướng dẫn sử dụng @ManyToMany"
    }, {
    "id": 29,
    "url": "https://loda.me/Huong-dan-tu-tao-mot-Annotations/",
    "title": "「Java」Hướng dẫn tự tạo một Annotations",
    "body": "2019/04/03 - Annotation (Chú thích) được sử dụng để chú thích trên một class, một trường (field) hoặc một method để cung cấp hoặc bổ sung các thông tin. Nó hoàn toàn không ảnh hưởng tới code của bạn. Trong bài có sử dụng các kiến thức:  Optional Functional Interface &amp; Lambda Java ReflectionAnnotation được sử dụng ở 3 dạng:  Chú thích cho trình biên dịch (Compiler) Chú thích cho quá trình build Chú thích trong quá trình chạy chương trình (Runtime)Hẳn bạn đã 1 lần từng thấy cái @Override phải không? nó là một Annotation chú thích cho trình biên dịch, để cho trình biên dịch biết hàm đó đã bị ghi đè. Còn chú thích cho quá trình build thì không hẳn có ví dụ cụ thể, nhưng bạn hãy nghĩ tới Maven, Gradle những công cụ build này sẽ có thêm thông tin khi build ứng dụng của bạn khi gặp một số Annotation đặc biệt, và sẽ bổ sung thêm code vào đó. Chú thích trong quá trình chạy chương trình sẽ là nội dung chính của chúng ta hôm nay. Đây là những Annotation mà chỉ khi bạn chạy chương trình rồi thì nó mới tác động tới code. Cùng vào ví dụ để dễ hiểu nhé! Khai báo Annotation: Cách khai báo Annotation là sử dụng @interface public @interface JsonName {  String value(); // các giá trị trong @interface đều dạng hàm abstract, không tham số}vậy là bạn đã có 1 Annotation. Giờ gọi nó ra và sử dụng: @JsonName(value =  super_man )public class SuperMan extends Person {  private String name;}Đơn giản phải không? Tuy nhiên, hiện tại Annotation chỉ hiển thị trong code như vậy thôi! chứ nó chả có tác dụng gì cả :)))) Chúng ta cần viết thêm code để xử cái lý cái @JsonName này. Khai báo phạm vi cho Annotation: Chúng ta có thể quy định phạm vi sử dụng của Annotation bằng cách: @Retention(RetentionPolicy. RUNTIME) // Tồn tại trong lúc chạy chương trình@Target({ ElementType. TYPE, ElementType. FIELD, ElementType. METHOD}) // Được sử dụng trên class, interface, method, biếnpublic @interface JsonName {  String value();}@Retention: Dùng để chú thích mức độ tồn tại của một annotation nào đó. Cụ thể có 3 mức nhận thức tồn tại của vật được chú thích:  RetentionPolicy. SOURCE: Tồn tại trên code nguồn, và không được bộ dịch (compiler) nhận ra.  RetentionPolicy. CLASS: Mức tồn tại được bộ dịch nhận ra, nhưng không được nhận biết bởi máy ảo tại thời điểm chạy (Runtime).  RetentionPolicy. RUNTIME: Mức tồn tại lớn nhất, được bộ dịch (compiler) nhận biết, và máy ảo (jvm) cũng nhận ra khi chạy chương trình. @Target: Dùng để chú thích phạm vi sử dụng của một Annotation  ElementType. TYPE - Cho phép chú thích trên Class, interface, enum, annotation.  ElementType. FIELD - Cho phép chú thích trường (field), bao gồm cả các hằng số enum.  ElementType. METHOD - Cho phép chú thích trên method.  ElementType. PARAMETER - Cho phép chú thích trên parameter ElementType. CONSTRUCTOR - Cho phép chú thích trên constructor ElementType. LOCAL_VARIABLE - Cho phép chú thích trên biến địa phương.  ElementType. ANNOTATION_TYPE - Cho phép chú thích trên Annotation khác ElementType. PACKAGE - Cho phép chú thích trên package. Xử lý Annotation: Bước 1: Chú thích bất kì chỗ nào bạn thích :))) @JsonName(value =  super_man )public class SuperMan {  // Không chú thích, thì chúng ta sẽ coi như lấy tên field là `name` luôn  private String name;  @JsonName( date_of_birth )  private LocalDateTime dateOfBirth;  public String getName() {    return name;  }  public void setName(String name) {    this. name = name;  }  public LocalDateTime getDateOfBirth() {    return dateOfBirth;  }  public void setDateOfBirth(LocalDateTime dateOfBirth) {    this. dateOfBirth = dateOfBirth;  }}Bước 2: Viết class xử lý @JsonName: public class JsonNameProcessor {  public static String toJson(Object object) throws IllegalAccessException {    StringBuilder sb = new StringBuilder(); // Dùng StringBuilder de tao json tu class    Class&lt;?&gt; clazz = object. getClass();    JsonName jsonClassName = clazz. getDeclaredAnnotation(JsonName. class); // Lay ra annotation @JsonName tren Class    sb. append( {\n )     . append( \t\  )     // Lay gia tri cua Annotation, neu annotation la null thi lay ten Class de thay the     . append(Optional. ofNullable(jsonClassName). map(JsonName::value). orElse(clazz. getSimpleName()))     . append( \ : {\n ); //    Field fields[] = clazz. getDeclaredFields();    for (int i = 0; i &lt; fields. length; i++) {      fields[i]. setAccessible(true); // Set setAccessible = true. De co the truy cap vao private field      JsonName jsonFieldName = fields[i]. getDeclaredAnnotation(JsonName. class); // get annotation tren field      sb. append( \t\t\  )       // Lay gia tri cua Annotation, neu annotation la null thi lay ten field thay the       . append(Optional. ofNullable(jsonFieldName). map(JsonName::value). orElse(fields[i]. getName())) // L       . append( \ :  )       // Neu field la String hoac Object. thi append dau ngoac kep vao       . append(fields[i]. getType() == String. class || !fields[i]. getType(). isPrimitive() ?  \   :   )       // Lay gia tri cua field       . append(fields[i]. get(object))       // Neu field la String hoac Object. thi append dau ngoac kep vao       . append(fields[i]. getType() == String. class || !fields[i]. getType(). isPrimitive()?  \   :   )       // Nếu là field cuối cùng, thì không append dấu  ,        . append(i != fields. length -1 ?  ,\n  :  \n );    }    sb. append( \t}\n );    sb. append( } );    return sb. toString();  }}Bước 3: Chạy thử: public static void main(String[] args) throws IllegalAccessException {  SuperMan superMan = new SuperMan(); // Tao doi tuong super man  superMan. setDateOfBirth(LocalDateTime. now());  superMan. setName( loda );  String json =JsonNameProcessor. toJson(superMan);  System. out. println(json);}// OUTPUT:/*{	 super_man : {		 name :  loda ,		 date_of_birth :  2019-04-03T21:07:23. 983 	}}*/Vậy là các bạn đã thành công cho việc tự tạo cho mình 1 Annotation rồi :v Chúc các bạn học tập tốt hihi :3 "
    }, {
    "id": 30,
    "url": "https://loda.me/Huong-dan-Java-Reflection/",
    "title": "「Java」Hướng dẫn Java Reflection",
    "body": "2019/04/03 - Java Relection là một core package trong thư viện chuẩn của Java. Mục đích của nó là cho phép chúng ta truy cập vào gần như mọi thứ bên trong đối tượng. “Dưới một góc độ khác”! Chúng ta thường biết tới Java thông qua khái niệm hướng đối tượng như sau: String str =  Hello Loda ;str. toUpperCase(); // Chúng ta gọi hàm toUpperCase() thông qua toán tử  .  // Mọi thứ trong đối tượng là khép kín, chúng ta phải gọi thông qua hàm publicHoặc public class Girl {  String name;  int age;  int atk;  int agi;  int def;  // . . . Và 1000 thuộc tính khác  public static void main(String[] args) {    Girl girl = new Girl();    // Chúng ta thường phải nhớ tên thuộc tính để gọi nó ra    girl. name =  Ngoc Trinh ;    // Giá sử class này có 100 thuộc tính là String.     // Bạn muốn set giá trị của tất cả trường String là  Ngoc Trinh     // Bạn sẽ rất bối rối vs việc gọi từng thuộc tính bằng việc  . {tên thuộc tính}  như này.     // Có cách nào cho code duyệt tìm toàn bộ thuộc tính, cái nào là String thì đổi nó thành  Ngoc Trinh ?  }}Đúng vậy, khi chúng ta muốn gọi tên thuộc tính, mà lại không muốn gõ . và nhớ ra tên thuộc tính, thì làm như nào? Bây giờ, chúng ta phải tiếp cận từ góc nhìn khác. Chúng ta sẽ ước mình có thể duyệt hết tất cả các thuộc tính của 1 class bằng vòng lặp. Rồi check xem thuộc tính có là String không? nếu có thì gán giá trị mới là “Ngoc Trinh”! Để làm được điều này, chúng ta cần đào sâu vào Class và phá vỡ giới hạn của java truyền thống. Đây là lúc Java Reflection (Sự phản chiếu) vào trận. Java Reflection: Java Reflecion cho phép bạn đánh giá, sửa đổi cấu trúc và hành vi của một đối tượng tại thời gian chạy (runtime) của chương trình. Đồng thời nó cho phép bạn truy cập vào các thành viên private (private member) tại mọi nơi trong ứng dụng, điều này không được phép với cách tiếp cận truyền thống. Lấy ra Thuộc tính (Field): Quay trở lại ví dụ trên, Chúng ta sẽ lấy ra toàn bộ thuộc tính của Girl. Tìm xem cái nào tên name và bổ sung giá trị mới cho nó. public class Girl {  private String name;  public Girl() {  }  public Girl(String name) {    this. name = name;  }  public void setName(String name){    this. name = name;  }  @Override  public String toString() {    return  Girl{  +         name='  + name + '\'' +        '}';  }  public static void main(String[] args) throws Exception {    Girl girl = new Girl(); // KHởi tạo đối tượng Girl    girl. setName( Ngoc trinh );    // Lay ra tat ca field cua object    // Chỉ để bạn xem ví dụ thôi, bỏ qua phần này nhé!    for(Field field : girl. getClass(). getDeclaredFields()){      System. out. println();      System. out. println( Field:   +field. getName());      System. out. println( Type:   +field. getType());    }    // PHẦN CHÍNH    Field nameField = girl. getClass(). getDeclaredField( name ); // Lấy ra field có tên  name  (nếu không tìm thấy, nó sẽ bắn NoSuchFieldException)    nameField. setAccessible(true); // Cho phép truy cập tạm thời. (Vì nó đang là Private mà)    // Bây giờ cái  nameField  đại diện cho thuộc tính  name  của mọi object có class Girl.     nameField. set(girl,  Bella ); // thay giá trị mới của `girl` bằng nameField.         System. out. println(girl);  }}// Output:// Field: name// Type: class java. lang. String// Girl{name='Bella'}Lấy ra Hàm (Method): Vấn đề đặt ra, giống với field. Chúng ta cũng sẽ có nhu cầu duyệt tìm một method nào đó và sử dụng nó: public static void main(String[] args) throws Exception {  Class&lt;Girl&gt; girlClass = Girl. class;  // Su dung getDeclaredMethods de lay ra nhung method cua class va cha no.   Method[] methods = girlClass. getDeclaredMethods();  for(Method method : methods){    System. out. println();    System. out. println( Method:   + method. getName());    System. out. println( Parameters:   + Arrays. toString(method. getParameters()));  }  // Lay ra method ten la setName va co 1 tham so truyen vao -&gt;   // =&gt; chính là: setName(String name)  Method methodSetName = girlClass. getMethod( setName , String. class);  // Bây giờ methodSetName sẽ đại diện cho method setName(String name) của mọi object có class là Girl  Girl girl = new Girl(); // Tạo ra đối tượng Girl  // Thực hiện hàm setName() trên đối tượng girl, giá trị truyền vào là  Ngoc Trinh   methodSetName. invoke(girl,  Ngoc Trinh );  System. out. println(girl);}Lấy ra Constructor: Lấy ra hàm khởi tạo của một class. Từ đó cho phép chúng ta cách tạo ra đối tượng từ theo một cách khác, thay vì new Class() như bình thường public static void main(String[] args) {  Class&lt;Girl&gt; girlClass = Girl. class;  System. out. println( Class:   + girlClass. getSimpleName());  System. out. println( Constructors:   + Arrays. toString(girlClass. getConstructors())); // Lấy ra toàn bộ Constructor của class này  try {    // Tạo ra một object Girl từ class. (Khởi tạo không tham số)    Girl girl1 = girlClass. newInstance();    System. out. println( Girl1:   + girl1);    // Lấy ra hàm constructor với tham số là 1 string     // Chính là -&gt; public Girl(String name) {}    Constructor&lt;Girl&gt; girlConstructor = girlClass. getConstructor(String. class);    Girl girl2 = girlConstructor. newInstance( Hello );    System. out. println( Girl2:   + girl2);  } catch (Exception e) {    // Exception xay ra khi constructor khong ton tai hoac tham so truyen vao khong dung    e. printStackTrace();  }}Lấy ra Annotation trên Field, Method, Class: Đúng vậy, đây cũng chính là một trong những phần quan trọng bậc nhất của Java Reflection. Cho phép chúng ta kiểm tra Class hiện tại đang được chú thích bởi những Annotation nào. @SuppressWarnings( deprecation )@Deprecatedpublic class Girl {  private String name;  public Girl() {  }  public Girl(String name) {    this. name = name;  }  @Nullable  public void setName(String name){    this. name = name;  }  @Override  public String toString() {    return  Girl{  +         name='  + name + '\'' +        '}';  }  public static void main(String[] args) {    Class&lt;Girl&gt; girlClass = Girl. class;    System. out. println( Class:  +girlClass. getSimpleName()); // Lấy ra tên Class    for(Annotation annotation : girlClass. getDeclaredAnnotations()){      System. out. println( Annotation:   + annotation. annotationType()); // Lấy ra tên các Annatation trên class này    }    for(Method method: girlClass. getDeclaredMethods()){ // Lấy ra các method của class      System. out. println( \nMethod:   + method. getName()); //Tên method      for(Annotation annotation : method. getAnnotations()){        System. out. println( Annotation:   + annotation. annotationType()); // Lấy ra tên các Annatation trên method này      }    }  }}Với cách này, bạn hoàn toàn có thể tự tạo ra 1 Annotation và xử lý nó, Chi tiết xem tại: Hướng dẫn tự tạo Annotation Bài viết tới đây kết thúc, bạn đã có thể sử dụng Java Reflection xoành xoạch rồi đó, chúc bạn học tập tốt ahoho! "
    }, {
    "id": 31,
    "url": "https://loda.me/Huong-dan-tao-Spring-Boot-voi-nhieu-modules-bang-Gradle/",
    "title": "Hướng dẫn tạo Spring Boot với nhiều modules bằng Gradle",
    "body": "2019/03/30 - Gradle là một open-source có nhiệm vụ tự động hóa quá trình đóng gói một dự án với ưu điểm chính khả năng tùy biến cao và cho hiệu năng tốt. Gradle ra đời sau và cải thiện các phần còn yếu của Maven như cú pháp khai báo rườm rà, khó quản lý, tốc độ build và test còn chưa được tối ưu. Để tận dụng những lợi thế này, hôm nay chúng ta sẽ tạo ra một project Spring boot với nhiều module với Gradle thay vì là Maven như truyền thống. Spring Initializr: Để tạo ra một project Spring, việc tạo bằng tay là hơi vất vả, vì thế chúng ta sẽ dùng Spring Initializr do Spring cung cấp. Bạn truy cập vào: https://start. spring. io Và đặt tên cho project và chọn build bằng Gradle như hình: Tiếp đến, chọn các dependencies đi kèm, và Generate Project Tải project về, và mở bằng Intellij IDEA Lần đầu nó sẽ phải download Gradle Wrapper nên hơi lâu chút, bạn ráng chờ hah. Sau khi nó sync xong thì sẽ được một project như này.  Okay, thế là xong phần khởi tạo 1 project rồi! Tạo module: Để phục vụ cho các mục đích khác nhau, mình sẽ chia project này thành 2 module là:    common: Mục đích là để chứa model dùng chung và repository của nó     service: Xử lý mọi thử ở đây  bạn tạo module bằng cách: Chuột phải &gt; New &gt; New Module Sau đó chọn, module là gradle &gt; java và nhập tên module: Như vậy là chúng ta có 2 cái module nho nhỏ như này: Config Build. gradle: Bây giờ chúng ta sẽ config lại build. gradle của từng module. Các file build. gradle đều có sẵn thông tin trong đó, nhưng bạn xóa hết đi và thêm lại như mình hướng dẫn ở dưới Tại build. gradle ở thư mục gốc. (multiple-module-gradle/build. gradle): // Tại build. gradle gốc, chúng ta config để các thằng module con có thể có chung cấu hình, kế thừa plugin và dependencies của thằng cha này luôn. // Như vậy thì lúc sau các module không cần config gì nữa. allprojects {	group 'me. loda. springboot'	version '1. 0-SNAPSHOT'	apply plugin: 'java'	apply plugin: 'idea'	repositories {		mavenCentral()		jcenter()	}}buildscript {	ext {		springBootVersion = '2. 1. 3. RELEASE'		springManagementVersion = '1. 0. 7. RELEASE'		lombokVersion = '1. 18. 4'		guavaVersion = '27. 1-jre'		commonLang3Version = '3. 8. 1'	}	repositories {		mavenCentral()		jcenter()	}	dependencies {		classpath( org. springframework. boot:spring-boot-gradle-plugin:${springBootVersion} )		classpath( io. spring. gradle:dependency-management-plugin:${springManagementVersion} )	}}subprojects {	apply plugin: 'io. spring. dependency-management'	apply plugin: 'org. springframework. boot'	sourceCompatibility = 1. 8	targetCompatibility = 1. 8	def defaultEncoding = 'UTF-8'	tasks. withType(AbstractCompile). each { it. options. encoding = defaultEncoding }	javadoc {		options. encoding = defaultEncoding		options. addBooleanOption('Xdoclint:none', true)	}	compileJava. dependsOn(processResources)	springBoot {		buildInfo()	}	dependencies{		annotationProcessor  org. springframework. boot:spring-boot-configuration-processor 		annotationProcessor  org. projectlombok:lombok:${lombokVersion} 		compileOnly  org. springframework. boot:spring-boot-configuration-processor 		compileOnly  org. projectlombok:lombok:${lombokVersion} 		// SPRING DEPENDENCIES		implementation 'org. springframework. boot:spring-boot-starter-data-jpa'		runtimeOnly 'mysql:mysql-connector-java'		// Utilities		compile group: 'com. google. guava', name: 'guava', version:  ${guavaVersion} 		compile group: 'org. apache. commons', name: 'commons-lang3', version:  ${commonLang3Version} 		// TEST		testImplementation 'org. springframework. boot:spring-boot-starter-test'	}}project(':service') {	dependencies {		implementation project(':common')		compile('org. springframework. boot:spring-boot-starter-web')		compile('org. springframework. boot:spring-boot-devtools')	}}project(':common'){}Tại build. gradle ở module service. (multiple-module-gradle/service/build. gradle): // thằng này bỏ trống các bạn ạ, sau có cần gì thì bổ sung thêmTại build. gradle ở module common. (multiple-module-gradle/common/build. gradle): bootJar. enabled=falsejar. enabled=true// thằng common này mình disable cái bootJar điViết chương trình demo: Chúng ta sẽ tạo ra một project đơn giản:    common: Chưa thông tin model User.     service: Tạo ra User và dùng tầng common để lưu nó  Common: Cấu trúc module common: // User. javaimport java. io. Serializable;import javax. persistence. Entity;import javax. persistence. GeneratedValue;import javax. persistence. Id;import lombok. Data;import lombok. RequiredArgsConstructor;@Entity@Data@RequiredArgsConstructorpublic class User implements Serializable {  @Id  @GeneratedValue  private Long id;  private final String name;}// UserRepositoryimport org. springframework. data. jpa. repository. JpaRepository;public interface UserRepository extends JpaRepository&lt;User, Long&gt; {}Chúng ta chỉ làm demo để chứng minh là các module đã hoạt động thôi :)))) Ở đây mình sử dụng H2 Database, là một dạng database lưu trữ trên bộ nhớ, được autoconfig trong Springboot rồi, nên các bạn chỉ cần tạo lớp User như kia, rồi chạy chương trình là nó tự tạo table tương ứng Còn Các annotation ngoại lai kia chính là của Lombok. Để hiểu nó có ý nghĩa gì và sức mạnh của Lombok bạn xem bài viết sau: Hướng dẫn sử dụng Lombok, giúp code Java nhanh hơn 69% Service: Bên module service chúng ta sẽ lấy tầng common ra xài: // Application. javaimport javax. transaction. Transactional;import org. springframework. boot. CommandLineRunner;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;import lombok. RequiredArgsConstructor;@SpringBootApplication@RequiredArgsConstructorpublic class Application implements CommandLineRunner {  public static void main(String[] args) {    SpringApplication. run(Application. class, args);  }// Không cần @Autowired, vì chúng ta có @RequiredArgsConstructor rồi  private final UserRepository userRepository;  @Override  @Transactional  public void run(String. . . args) throws Exception {    User user = new User( loda );    user = userRepository. save(user);    System. out. println(user);  }}Chạy chương trình: // Output// User(id=1, name=loda)// user được insert vào database là có id = 1. // project chạy thành công!Lời kết: Vậy là chúng ta đã tạo ra một project với nhiều module bằng Gradle và Spring boot. Có thể thấy Gradle cho phép chúng ta khai báo khá dễ đọc, và gọn gàng. Ngoài ra bản thân nó còn được cộng đồng open-source cung cấp nhiều plugin nên gần như chúng ta không cần làm gì nhiều, chỉ cần apply plugin là xong! Chi tiết project mình để tại Github. Chúc các bạn thành công! chớ quên like or share ủng hộ mềnh nha ahoho!:3 "
    }, {
    "id": 32,
    "url": "https://loda.me/Huong-dan-Stream-API/",
    "title": "「Java 8」Hướng dẫn Stream API",
    "body": "2019/03/27 - Stream là một trong những concept được coi là đem sự thay đổi lớn nhất trong Java 8. Để có thể hiểu được nội dung này trọn vẹn, mình đề nghị các bạn đọc trước các khái niệm sau: Functional Interfaces &amp; Lambda Expressions Optional Khái quát: Stream là một abtract layer cho phép bạn xử lý một dòng dữ liệu dựa trên các thao tác đã định nghĩa trước. Bạn có thể tạo Stream từ các nguồn dữ liệu như Collections, Arrays hoặc I/O resources. Collection&lt;String&gt; collection = Arrays. asList( hello ,  loda ,  kaka );Stream&lt;String&gt; streamOfCollection = collection. stream(); // Tạo ra một stream từ collectionMặc định các lớp kế thừa của Collection đều có hàm . stream(): List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream = list. stream(); // tạo ra 1 luồngStream&lt;String&gt; parallelStream = list. parallelStream(); // luồng dữ liệu song song (xử lý trên nhiều thread cùng lúc)Cách sử dụng: Chức năng của Stream là cực kì đa dạng giúp bạn thao tác dữ liệu dễ dàng hơn. forEach: Duyệt qua toàn bộ dữ liệu của bạn list. stream(). forEach(s -&gt; System. out. println(s));map: Tạo ra các giá trị mới từ dữ liệu hiện có Arrays. asList(3, 5, 7)  . stream() // tạo ra Stream từ List&lt;Integer&gt;  . map(i -&gt;  loda- +i) // biến đổi từng phần tử thành String   . map(String::toUpperCase) // biến đổi từng phần tử thành Upper case  . forEach(System. out::println); // in ra xem thửfilter: filter() gíup chúng ta thao tác với những dữ liệu mong muốn Arrays. asList(2, 3, 5, 7)  . stream()  . filter(i -&gt; i % 2 != 0) //từ đây trở đi, chúng ta chỉ muốn làm việc với số lẻ  . map(i -&gt;  loda-  + i)  . map(String::toUpperCase)  . forEach(System. out::println);limit: Giới hạn số lượng dữ liệu cần xử lý IntStream. range(1, 1000). boxed() // Tạo ra Stream có dữ liệu từ 1-&gt;999      . filter(i -&gt; i % 2 != 0)      . map(i -&gt;  loda-  + i)      . map(String::toUpperCase)      . limit(10) // Chúng ta giới hạn lấy 10 cái rồi in ra      . forEach(System. out::println);sorted: sắp xếp Stream IntStream. range(1, 1000). boxed() // Tạo ra Stream có dữ liệu từ 1-&gt;999      . filter(i -&gt; i % 2 != 0)      . map(i -&gt;  loda-  + i)      . map(String::toUpperCase)      . limit(10)      . sorted() // Sắp xếp dữ liệu đã xử lý      . forEach(System. out::println);// OUTPUT: /*LODA-1LODA-11LODA-13LODA-15*/// đây là vì dữ liệu là String, nó đang sort StringStringBạn có thể tự định nghĩa cách sort bằng cách thêm Comparator vào sorted((o1, o2) -&gt; o1. compareTo(o2))collect: collect giúp chúng ta lấy toàn bộ dữ liệu đã biến đổi trong Stream thành đối tượng mình mong muốn List&lt;String&gt; result = IntStream. range(1, 1000). boxed()                . filter(i -&gt; i % 2 != 0)                . map(i -&gt;  loda-  + i)                . map(String::toUpperCase)                . limit(10)                . sorted(Comparator. naturalOrder()) // một cách khác để sort                . collect(Collectors. toList());Xử lý song song: List&lt;String&gt; result = IntStream. range(1, 1000). boxed()                . parallel() // tạo một Stream xử lý dữ liệu song song, tương đương với parallelStream()                . filter(i -&gt; i % 2 != 0)                . map(i -&gt;  loda-  + i)                . map(String::toUpperCase)                . limit(10)                . sorted(Comparator. naturalOrder()) // một cách khác để sort                . collect(Collectors. toList());Bản chất của Stream: Bạn hãy chạy chương trình này nhé List&lt;String&gt; result = Stream. of( bạn ,  hãy ,  like ,  Fanpage ,  loda , dể , cập , nhật , nhiều , hơn )              . filter(s -&gt; {                System. out. println( [filtering]   + s);                return s. length()&gt;=4;              })              . map(s -&gt; {                System. out. println( [mapping]   + s);                return s. toUpperCase();              })              . limit(3)              . collect(Collectors. toList());System. out. println( ---------------------- );System. out. println( Result: );result. forEach(System. out::println);Kết quả: [filtering] bạn // không thoả mãn[filtering] hãy // tiếp tục tìm, cũng k thoả mãn[filtering] like // thoả mãn[mapping] like // mapping nó luôn[filtering] Fanpage // lại quay lại filter tìm tiếp, thoả mãn[mapping] Fanpage // mapping[filtering] loda // thoả mãn[mapping] loda // mapping// Đủ 3 trường hợp thoả mãn, dừng. ----------------------Result:LIKEFANPAGELODABạn sẽ thấy rằng chương trình chỉ xử lý dữ liệu vừa đủ thoả mãn điều kiện limit(3) mà thôi, còn lại nó sẽ bỏ qua để tối ưu hoá performance. Chứng tỏ Stream là Lazy evaluation. Hiểu đơn giản là nó sẽ không xử lý dữ liệu trực tiếp qua từng bước, mà chờ bạn khai báo xong tất cả các thao tác operation như map, filter,v. v. . cho tới khi gặp lệnh . collect() thì nó thực hiện toàn bộ trong một vòng lặp duy nhất. Hàm . collect() và một số hàm như min(), max(), count() được gọi là terminal operation. Khi gọi những function có dạng terminal thì Stream mới chính thức hoạt động. Một lưu ý khi sử dụng là Stream không được tái sử dụng. Ví dụ: Stream&lt;String&gt; stream =  Stream. of( loda ,  .  ,  me , like ). filter(element -&gt; element. contains( e ));Optional&lt;String&gt; anyElement = stream. findAny(); //Lấy ra một phần tử bất kỳ trong Stream, nó sẽ trả ra Optional // Thực hiện dòng lệnh tiếp theo sẽ bắn ra IllegalStateExceptionOptional&lt;String&gt; firstElement = stream. findFirst();Vì Stream được tạo ra để xử lý dữ liệu chứ không phải để lưu trữ! Nên muốn sử dụng, mỗi lần bạn sẽ cần tạo ra 1 Stream mới. Lời kết: Tới đây là bạn đã có thể sử dụng Stream để giúp code của mình bá đạo hơn bao giờ hết rồi đấy! Chúc bạn thành công, và chớ quên chia sẻ cho bạn bè nhé, ohoho :3 "
    }, {
    "id": 33,
    "url": "https://loda.me/Functional-Interfaces-&-Lambda-Expressions-cuc-de-hieu/",
    "title": "「Java 8」Functional Interfaces & Lambda Expressions cực dễ hiểu",
    "body": "2019/03/27 - Khái niệm Functional Interfaces được Java đưa ra cùng với phiên bản Java 8. về cơ bản, có thể hiểu:  Functional Interfaces là interface nhưng chỉ có một 1 abstract function duy nhất. Ví dụ: interface Runable{  public void run(); // Chỉ có duy nhất một abstract function. }Dễ hiểu phải hem các bạn :3 Tuy nhiên, vì sao lại đưa ra khái niệm này và nó giúp ích gì cho developer như chúng ta. Functional Programming: Trước khi đi vào chi tiết, chúng ta cùng tìm hiểu khái niệm Lập trình hướng hàm. Cùng xem ví dụ dưới đây: public static void main(String[] args) {  // Mình muốn xử lý dữ liệu trước khi ỉn ra màn hình.   System. out. println(process( Hey Loda!!! ));}public static String process(String input){  // Cho tất cả viết hoa lên.   return input. toUpperCase();}// Output: HEY LODA!!!Dễ quá phải hem bạn :))) Tuy nhiên bạn sẽ thấy cách làm này không flexible, vì các bạn chỉ có thể xử lý cho chữ thành UPPER CASE. Muốn làm gì đó khác, như toLowerCase chẳng hạn, mình sẽ phải viết một function mới. Chúng ta giải quyết cách cách này bằng Anonymous function (Hàm ẩn danh) Sửa code chút: public interface StringProcessor{  public String process(String input);}public static String getStr(String input, StringProcessor processor){  return processor. process(input);}public static void main(String[] args) {  // In ra chữ hoa  System. out. println(getStr( Hello Loda! , new StringProcessor() {    @Override    public String process(String input) {      return input. toUpperCase();    }  }));  // In ra chữ thường  System. out. println(getStr( Hey Loda! , new StringProcessor() {    @Override    public String process(String input) {      return input. toLowerCase();    }  }));}// Output:// HELLO LODA!// hey loda!Đây chính là Lập trình hướng hàm các bạn ạ, mục đích của nó là chúng ta đưa hành vi vào hàm. Hay nói cách khác là đưa thêm các đoạn code vào hàm như là một parameter.  Lập trình hướng hàm là đưa hành vi vào hàm. Tuy nhiên có một nhược điểm trong khi áp dụng cách này đó là viết code rất dài 😭 Chỉ mỗi việc in ra màn hình cũng mất của chúng ta 6-7 dòng code. Đây là lúc mà Lambda Expressions ra đời. Lambda Expressions: Quay lại ví dụ ở trên, cùng phân tích: Chúng ta thấy là StringProcessor chỉ có duy nhất một function process(xx) (liên tưởng gì chưa các bạn :3). Nên mọi đoạn code đều sẽ giống hệt nhau ở việc implement function này. new StringProcessor() {  @Override  public String process(String input) {    // Do something here    // Chỉ khác nhau đoạn code ở giữa    return x;  }}Thực ra cái chúng ta quan tâm là:  đầu vào input (String) một hoặc nhiều thao tác xử lý input cho tôi đầu ra là output (String)đúng chứ? Có cách nào để rút ngắn code hơn, nhưng vẫn không làm nhập nhằng ý nghĩa của code? Java 8 thấu hiểu sự bất cập này và đưa ra khái niệm Lambda Expression: // (input) -&gt; input. toUpperCase()// đầu vào -&gt; đầu raSystem. out. println(getStr( Hello Loda! , input -&gt; input. toUpperCase())); Lambda Expression là một cách định nghĩa ngắn gọn khi implement một Functional Interface (interface chỉ có một function) Cấu trúc của một lambda như sau: parameter -&gt; expression bodyTrong đó:    parameter là những tham số đầu vào của hàm (một hoặc nhiều)     expression body là phần xử lý parameter, bạn cần trả ra đúng kiểu dữ liệu đã khai báo trong Functional Interface  Nếu code bạn chỉ cần 1 thao tác, thì không cần return giống ví dụ ở trên. Còn nếu code yêu cầu xử lý nhiều, thì dạng đầy đủ của nó như sau: parameter -&gt; {  expression body  [return] // (không trả về nếu là void)}ví dụ: System. out. println(getStr( Hello Loda! , input -&gt; {  String temp = input +   Đừng quên like fanpage nhé!!! ;  return temp. toLowerCase();}));Functional Interface: Tới đây, bạn đã hiểu ý nghĩa của việc cho ra đời khái niệm Functional Interface, nó là một quy định chung phải có để có thể viết code dưới dạng biểu thức Lambda. Một số điều cần lưu ý với Functional Interface như sau: @FunctionalInterfaceAnnotation này chỉ để bổ sung, nó đánh dấu một interface là Functional Interface. Lúc này bạn khai báo 2 abtract function bên trong interface thì sẽ báo lỗi. @FunctionalInterface // Gắn cái này lên interface, nó đánh dấu interface chỉ được phép có 1 funtion thôipublic interface StringProcessor{  public String process(String input);  public String preProcess(String input); // lỗi}default function &amp; static funtion: Java 8 cải tiến cho phép interface được khai báo code bên trong nó, với điều kiện code phải nằm trong default hoặc static. default và static không phá vỡ quy luật của @FunctionInterfaces @FunctionalInterface // Gắn cái này lên interface, nó đánh dấu interface chỉ được phép có 1 funtion thôipublic interface StringProcessor{  public String process(String input);  // Mọi class implement StringProcessor đều có thể gọi hàm này để sử dụng luôn  public default void printf(Object t){    System. out. println(t);  }  // Là hàm static, gọi từ class cũng được.     StringProcessor. concat(a,b)  public static String concat(String a, String b){    return a + b;  }}Method reference: Phần này chỉ để bổ sung, không có nó, bạn vẫn có thể sử dụng Lambda Expressions bình thường. Nhưng với Method reference, code của bạn sẽ còn sạch sẽ hơn nữa. Ví dụ: System. out. println(getStr( Hello Loda! , input -&gt; input. toUpperCase()));// Tương đương với việc viết như này:System. out. println(getStr( Hello Loda! , String::toUpperCase));Method reference là cách viết ngắn gọn, sẽ bỏ qua luôn cả phần parameter vì bản thân tên hàm đã biết nó sẽ nhận vào gì và trả ra cái gì rồi. Việc còn lại để Compiler lo thôi kakaka. Có các cách để gọi Method reference như sau: [Tên Class]::[Tên method]: Giống với ví dụ ở trên String::toUpperCase. [Tên Class]::new: Tạo ra một đối tượng mới, từ tham số được truyền vào System. out. println(getStr( Hello Loda! , input -&gt; new String(input));// Tương đương với việc viết như này:System. out. println(getStr( Hello Loda! , String::new));Lời kết: Tới đây, bạn đã nắm trong tay những khái niệm được coi là mạnh mẽ nhất Java 8 rồi :))) Cầm và quẩy trong tất cả các đoạn code sắp tới của mình nhé. Chúc các bạn thành công và nhớ like và chia sẻ cho bạn biết nhé, ahoho! "
    }, {
    "id": 34,
    "url": "https://loda.me/Vi-sao-nen-su-dung-StringBuffer/",
    "title": "「Java」Vì sao nên sử dụng StringBuffer",
    "body": "2019/03/26 - hẳn những ai biết tới Java thì không còn xa lạ gì với việc ghép các String với nhau. String s =  Hello ;s+=   world ;System. out. println(s + !!! );Đây là một kiến thức cực kì cực kì cơ bản. Tuy nhiên, nếu chúng ta tăng số lượng phép nối xâu này lên thì sẽ có hệ quả gì. Cùng xem ví dụ này nhé: long start = System. nanoTime();String s =  Hello ;for (int i = 0; i &lt; 1000; i++) {  s +=   world ;}long end = System. nanoTime();System. out. println( Total time:  +(end-start));// Kết quả:// Total time: 17495917 ns// = 17. 4 ms (Milliseconds)Bây giờ, vẫn là chương trình tương tự, mình sử sụng String Buffer long start = System. nanoTime();StringBuffer sb = new StringBuffer( Hello );for (int i = 0; i &lt; 1000; i++) {  sb. append(  world );}String s = sb. toString();long end = System. nanoTime();System. out. println( Total time:  +(end-start));// Kết quả:// Total time: 461198 ns// = 0. 46 msString Buffer nhanh hơn gấp 38 lần. Hiệu năng được chạy trên Mac Pro 2017, tại máy bạn có thể sẽ khác, nhưng chắc chắn rằng StringBuffer luôn nhanh hơn! Góc giải thích: Có một điều ít bạn học lập trình Java để ý, đó là String là immutable. Tức nội dung trong String là không được quyền thay đổi. Nhiều bạn lầm tưởng rằng việc nối xâu là bạn thay đổi nội dung của String, nhưng thực chất bạn đang tạo ra một đối tượng hoàn toàn mới: String s =  A ;s+= B ;// Complier sẽ tạo ra một đối tượng mới là  AB // Và gán vào `s`// Bản chất `s` bây giờ là một đối tượng mới chứ bạn không hề thay đổi nội dung ban đầu của `s`. // Đây là những gì ở dưới Compiler sẽ làm:StringBuffer sb = new StringBuffer( A ); // Compiler Vẫn phải xài tới StringBuffersb. append( B );s = sb. toString();Vì vậy khi nối xâu trong Java, việc bạn thực hiện nó liên tục, sẽ tương đương với việc khởi tạo liên tục và nối 2 xâu lại rồi trả về đối tượng String mới dẫn tới chi phí lớn. StringBuffer cho phép chúng ta thao tác trên một đối tượng duy nhất và thay đổi được nội dung trong nó. Nếu ban đầu nội dung là  A , bạn muốn nối thêm  B  vào. Thì nó chỉ cần gắn chuỗi bytes của  B  vào liền kề ngay sau  A  là xong. (Vì nó có thể thay đổi, khác với String là immutable). Tới đây bạn đã hiểu rõ vài trò của StringBuffer trong Java, vì thế hãy tận dụng nó một cách tối ưu, thay vì việc cộng các String như thông thường. "
    }, {
    "id": 35,
    "url": "https://loda.me/Optional/",
    "title": "「Java 8」Optional",
    "body": "2019/03/26 - Trước khi đi vào bài hôm nay, chúng ta cùng nghe cha đẻ của Null phát biểu :)))  Tôi gọi nó “sai lầm tỉ đô” 😂 hết Đùa đấy, vẫn còn  null reference được tôi tạo ra năm 1965. vào thời điểm đó, tôi đã thiết kế tổng quan hệ thống tham chiếu dữ liệu cho ngôn ngữ lập trình hướng đối tượng. Mục tiêu của tôi là đảm bảo các tham chiếu tuyệt đối an toàn và được kiểm tra tự động bởi compiler. Nhưng,… Tôi đã không thể cưỡng lại được ham muốn đặt thêm thằng cu null vào hệ thống. Vì nó giúp implement dễ hơn :))) Điều này vô tình dẫn tới vô số lỗi, lỗ hổng và sự cố hệ thống, gây ra bao đau đớn và thương nhớ cho hàng triệu developer và cũng giúp nhiều công ty thiệt hại hàng tỉ dollar. Những lời tâm sự muộn màng :((( Chắc hẳn trong chúng ta ai cũng một lần bị ám ảnh bởi NullPointerException huhu. Mặc dù tới nay, các ngôn ngữ mới đều đã kiểm soát null để đảm bảo những dòng code được an toàn (Scala, Kotlin). Tuy nhiên, Java chưa nằm trong số đó :))) Nhưng phòng còn hơn tránh, Java 8 ra đời cùng với một class mới tên là Optional. Nhiệm vụ của nó là kiểm soát null hộ chúng ta. Khái niệm Optional: Optional&lt;T&gt; là một đối tượng Generic, nhiệm vụ chính của nó là bọc hay wrapper lấy một object khác. Nó chỉ chứa được một object duy nhất bên trong. Việc bạn lấy giá trị của object bây giờ sẽ thông qua Optional và nếu object đó null cũng không sao, vì thằng Optional kiểm soát nó chặt chẽ hơn là if else. Ví dụ bạn có một đối tượng bất kỳ: String str = null;// Tạo ra một đối tượng OptionalOptional&lt;String&gt; optional = Optional. ofNullable(str);// Bây giờ Optional đã wrap lấy cái str. Khi chúng ta thực hiện các thao tác, chúng ta có thể kiểm tra như thế này: if (optional. isPresent()) {  System. out. println(opt. get()); // lấy ra cái str mình đã wrapper}Hmmm…. . trông thế này thì khác đếch gì if (str != null) =))) Nhiều bạn sẽ tự nghĩ. Đúng là như vậy, nếu nó chỉ làm được đến đây, thì thôi. . nghỉ mịa đee huhu :(( Bây giờ mình sẽ giới thiệu từng tính năng lần lượt của Optional để bạn thấy nó kì diệu như nào. ifPresent: optional. ifPresent(s -&gt; System. out. println(s));ifPresent nhận vào một Consumer, nó cũng chỉ là Functional Interface thôi các bạn. Nhận vào một đối tượng và thao tác trên nó, không return gì cả. Nếu bạn chưa rõ Functional Interface và Lambda Expression thì bạn có thể xem ngay đây, dễ hiểu lém: Functional Interfaces &amp; Lambda Expressions cực dễ hiểu orElse() và orElseGet(): orElse() lấy ra object trong Optional. Nếu null, trả về giá trị mặc định do bạn quy định String b = optional. orElse( Giá trị mặc định );orElseGet() Tương tự orElse() nhưng trả ra bằng Supplier interface String b = optional. orElseGet(() -&gt; {  StringBuilder sb = new StringBuilder();  // Thao tác phức tạp  return sb. toString();});map(): map() giúp chúng ta biến đổi đối tượng bên trong Optional. mình sẽ ví dụ bằng code dễ hiểu hơn. class Outfit{  public String type;  public String getType() { return type; }}class Girl{  private Outfit outfit;  public Outfit getOutfit() { return outfit; }}public String getOutfitType(Girl girl){  return Optional. ofNullable(girl) // Tạo ra Optional wrap lấy girl    . map(Girl::getOutfit) // nếu girl != null thì lấy outfit ra xem kakaka :3 ngược lại trả ra Optional. empty()    . map(Outfit::getType) // nếu outfit != null thì lấy ra xem type của nó    . orElse( Không mặc gì ); // Nếu cuối cùng là Optional. empty() thì trả ra ngoài Không mặc gì. }code trông sáng sủa hơn nhiều phải không bạn :3 Trong code ở trên sử dụng Method reference, khái niệm này mình đã nói chi tiết tại đây: Hướng dẫn Method Reference và Lambda Expressions Khái niệm map() mình có nói chi tiết tại đây: Stream Trong Java 8 cực dễ hiểu! filter(): filter() giúp chúng ta kiểm tra giá trị trong Optional nếu không thỏa mãn điều kiện, trả về empty() public String getOutfitType(Girl girl){  return Optional. ofNullable(girl) // Tạo ra Optional wrap lấy girl    . map(Girl::getOutfit)    . map(Outfit::getType)    . filter(s -&gt; s. contains( bikini )) // Nó chỉ chấp nhận giá trị bikini, còn lại dù khác null thì vẫn trả ra ngoài là Optiional. empty()    . orElse( Không mặc gì ); // Nếu cuối cùng là Optional. empty() thì trả ra ngoài  Không mặc gì . Tới đây mình đã giới thiệu xong với các bạn các tính năng khá hay ho của Optional. Ngoài việc giúp chúng ta kiểm soát NullException thì còn giúp code của chúng ta sáng sủa hơn rất nhiều và thuận tiện hơn trong nhiều trường hợp yêu cầu điều kiện phức tạp Chúc các bạn học tập thành công. Và chớ quên like và share ủng hộ nhá ahihi :3 "
    }, {
    "id": 36,
    "url": "https://loda.me/Huong-dan-lap-trinh-Spring-can-ban-va-@Autowired-cho-nguoi-moi/",
    "title": "「Spring」Hướng dẫn lập trình Spring căn bản cho người mới",
    "body": "2019/03/24 - Xin chào tất cả các bạn, trước khi đi vào chi tiết bài hôm nay, các bạn cần đọc cho mình các khái niệm sau: Khái niệm Dependency Injection và Inversion Of Control Nếu chưa biết các khái niệm này thì bạn nên đọc chúng tại link mình trích dẫn, sau đó quay lại học tiếp phần này, như vậy sẽ hiểu rõ hơn. IoC Container trong Spring: Nếu các bạn đã đọc bài viết Inversion of Control ở trên, sẽ thấy là Spring sẽ đảm nhiệm thay chúng ta việc khởi tạo object, quản lý nó hộ chúng ta. Khi các object cần các dependency gì nó sẽ inject luôn trong thời điểm khởi tạo. Đối tượng chịu trách nhiệm tạo và quản lý đó tên là IoC Container Đến đây nhiều bạn sẽ thắc mắc. Thế làm sao nó biết được Outfit lấy đâu ra, Accessories đâu ra, v. v. . Đúng, nó sẽ không biết lấy những cái ý ở đâu ra, nếu chúng ta không nói trước với IoC Container. Vậy nói với nó bằng cách nào? Để biết nó làm như thế nào thì mình sẽ vừa code vừa giải thích cho bạn. Tạo Spring Project với Maven: &lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;&lt;project xmlns= http://maven. apache. org/POM/4. 0. 0  xmlns:xsi= http://www. w3. org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven. apache. org/POM/4. 0. 0 http://maven. apache. org/xsd/maven-4. 0. 0. xsd &gt; &lt;modelVersion&gt;4. 0. 0&lt;/modelVersion&gt; &lt;groupId&gt;vn. loda. springboot&lt;/groupId&gt; &lt;artifactId&gt;dependency-injection&lt;/artifactId&gt; &lt;version&gt;1. 0-SNAPSHOT&lt;/version&gt; &lt;parent&gt;  &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  &lt;version&gt;2. 0. 5. RELEASE&lt;/version&gt; &lt;/parent&gt;  &lt;properties&gt;  &lt;maven. compiler. target&gt;1. 8&lt;/maven. compiler. target&gt;  &lt;maven. compiler. source&gt;1. 8&lt;/maven. compiler. source&gt; &lt;/properties&gt; &lt;dependencies&gt;  &lt;dependency&gt;   &lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;   &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;  &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;Các bạn tạo Project như bình thường và copy đoạn xml trên vào file pom. xml của bạn. Thế là chúng ta đã có một Spring project. Chúng ta sử dụng dependencies của Spring boot còn về bản chất thì không khác nhau. @Component: Tạo ra các Interface cần thiết: // Có cô gái nào mà không cần phụ kiện trên người cơ chứ :3 bông tai, vòng tay, v. v. . public interface Accessories {}// Có tý bồng bềnh phồng phềnh trên tóc ms xinh đc. public interface HairStyle {}// Cuối cùng là Outfitpublic interface Outfit { public void wear();}Implement tất cả các Interface này: import org. springframework. stereotype. Component;// Một bộ Bikini, bạn có thể tạo thêm nhiều bộ quần áo khác, chỉ cần implement Outfit là được@Componentpublic class Bikini implements Outfit { public void wear() {  System. out. println( Đã mặc Bikini ); }}// Phụ kiện Gucci nhờ :3@Componentpublic class GucciAccessories implements Accessories {  // Class chỉ mang tính minh họa, không có gì cả}// Tóc hàn quốc cho xinh@Componentpublic class KoreanHairStyle implements HairStyle {  // Class chỉ mang tính minh họa, không có gì cả}Ở đây các bạn sẽ thấy cái lạ mắt nhất chính là cái @Component. Nó là một Annotation được Spring cung cấp. import org. springframework. stereotype. Component;@Component: Sẽ báo cho IoC Container biết là bọn tao ở đây này, comehere. Vậy là IoC Container biết được có một thằng Bikini thuộc interface Outfit đang tồn tại nên sẽ Tạo ra đối tượng Bikini rồi lưu nó vào trong Container.  Lúc này, IoC Container đã và đang quản lý 3 đối tượng là Bikini, GucciAccessories, KoreanHair Và những đối tượng này được gọi với thuật ngữ là Bean  Bean ám chỉ đối tượng được Container quản lý @Autowired: Tạo ra class Girl: import org. springframework. beans. factory. annotation. Autowired;import org. springframework. context. annotation. Scope;import org. springframework. stereotype. Component;@Component@Scope( prototype )public class Girl { private Outfit outfit; private Accessories accessories; private HairStyle hairStyle; @Autowired public Girl(Outfit outfit, Accessories accessories, HairStyle hairStyle) {  this. outfit = outfit;  this. accessories = accessories;  this. hairStyle = hairStyle; } @Override public String toString() {  return  Girl{  +     outfit=  + outfit +     , accessories=  + accessories +     , hairStyle=  + hairStyle +    '}'; }}Các bạn thấy Girl cũng có @Component, vậy chúng ta hiểu nó cũng là 1 Bean, và IoC Container sẽ tới tìm và tạo ra nó. cái này giải thích ở trên rồi. Cái cần nói ở đây là cái thằng @Autowired. @Autowired: Là Annotation được chú thích trên một thuộc tính (field) hoặc function để nói với IoC Container là hãy tự inject những thuộc tính này vào hộ tao. Lúc này hành vi của thằng IoC Container sẽ như sau:    Nhận thấy Girl cũng có @Component nên nó phải tạo 1 Bean Girl     Thấy Girl có các thuộc tính còn thiếu, được đánh dấu @Autowired. Tìm trong Container các giá trị phù hợp và inject vào các thuộc tính có @Autowired     Tạo ra một new Girl từ những gì đã inject. Cất nó vào Container để quản lý luôn.   Chạy chương trình: import org. springframework. beans. factory. annotation. Autowired;import org. springframework. boot. CommandLineRunner;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;import org. springframework. context. ApplicationContext;@SpringBootApplicationpublic class Main implements CommandLineRunner { public static void main(String[] args) {  SpringApplication. run(Main. class, args); } @Autowired private ApplicationContext context; @Override public void run(String. . . args) throws Exception {  Girl girl = context. getBean(Girl. class);  System. out. println(girl); }}@SpringBootApplication: Chỉ cần sử dụng một lần trên class chính. Để nói rằng Project của chúng ta là Spring Project, nó sẽ Config tự động giúp bạn. // Bạn phải wrapper hàm Class có annotation @SpringBootApplication bằng SpringApplication. run() thì mới được Spring hỗ trợ. Còn không thì cái @SpringBootApplication cũng như vứt đi àSpringApplication. run(Main. class, args); Spring Boot đơn giản chỉ là một mở rộng của Spring Framework. kế thừa các tinh hoa và giảm thiểu hết các đoạn code thừa hoặc dài dòng đi. Vì cái hàm ` main(String[] args) của bạn đã bị wrapper bằng Spring. Nên bạn muốn chạy cái gì thì phải immplement cái CommandLineRunner và code mọi thứ trong cái hàm run(String… args) ` mà Spring cung cấp thì nó mới chạy. Tới đây, chúng ta sẽ thấy ApplicationContext. Cái này chính là IoC Container đấy các bạn. @Autowired // Bảo Spring tự inject chính cái Container của nó cho mình nghịch chútprivate ApplicationContext context; // Cái này có thể hiểu chính là Container đấy các bạn, nó chứa mọi Bean trong này. @Overridepublic void run(String. . . args) throws Exception {Girl girl = context. getBean(Girl. class); // Lấy Girl đã được tạo ra xem. System. out. println(girl);Girl girl2 = context. getBean(Girl. class);System. out. println(girl == girl2); // Kết quả ra False// Chứng tỏ mỗi lần lấy ra chúng ta tạo ra 1 Cô gái khác nhauOutfit outfit = context. getBean(Outfit. class);System. out. println(outfit);Outfit outfit2 = context. getBean(Outfit. class);System. out. println(outfit == outfit2); // Kết quả ra True// Chứng tỏ Outfit là singleton. }Khi chạy chương trình, bạn sẽ thấy là với class Girl thì mỗi lần lấy ra, nó là một instance hoàn toàn mới, nhưng Outfit thì bạn có lấy ra bao nhiều lần, nó vẫn chỉ là 1 instance duy nhất (singleton). Lý giải hiện tượng này, chúng ta quay lại ngược trở lại đoạn code Girl và Outfit, và sẽ nhận ra, chúng nó khác nhau duy nhất ở điểm chí mạng này: @Scope( prototype )Bạn xóa @Scope( prototype ) đi và chạy lại thử xem 😅 Đến đây bạn có thể hiểu, nếu như không nói gì. toàn bộ Bean trong IoC Container đều là Singleton. Còn nếu muốn Bean được khởi tạo theo ý mình, bạn phải cung cấp thêm Annotaion @Scope:    @Scope( prototype ): tương đương với việc tạo new Object     @Scope( singleton ): Không nói gì, thì Spring sẽ mặc định là scope này. Singleton, đôi tượng chỉ được tạo ra duy nhất một lần.  Ngoài ra còn có các kiểu scope bổ sung cho project dạng Web Application. Chúng ta chưa cần đề cập nó ở đây. @Configuration và @Bean: Bây giờ khi chạy chương trình tạo ra Girl ở trên, thì có một vấn đề là Cô gái nào cũng sẽ tự inject cái bộ Bikini vào người. Trong khi thực tế, mọi cô gái được tạo ra, đáng ra phải Naked mới đúng 😗 Mình quyết định sẽ config cho chương trình này một chút, để mọi Girl khi được tạo ra sẽ Naked: import org. springframework. context. annotation. Bean;import org. springframework. context. annotation. Configuration;@Configuration // Đánh dấu một Class là Config, class này sẽ được ưu tiên tìm kiếmpublic class GirlConfig { @Bean // Gắn đối tượng Outfit trả về trong hàm này là 1 bean. IoC Container sẽ quản lý nó giống @Component luôn public Outfit defaultOutfit(){  return new Naked(); // function này trả về một đối tượng Naked() }}public class Naked implements Outfit { @Override public void wear() {  System. out. println( ngượng quá điii!!! ); }}Mình giải thích: @Configuration: Là một Annotation đặc biệt của Spring. Khi một class được đánh dấu là @Configuration thì Spring hiểu class này là nơi chúng ta cấu hình, cài đặt và tạo ra những Bean cần thiết cho chương trình, nên nó sẽ chạy vào Class này trước tiên. @Bean: Chỉ được gắn trên function và nó sẽ đánh dấu đối tượng trả về trong function là bean và IoC Container sẽ phải quản lý nó. Tương tự @Component. tuy nhiên @Bean chỉ gắn trên function mà thôi. Về hành vi, IoC Container sẽ tìm kiếm, lục lọi tìm ra toàn bộ các @Configuration trong project và gọi hết các Function có chứa @Bean trong đó. Lấy ra các bean mà hàm trả về và quản lý nó. Có thể coi đây là một cách khởi tạo ra bean cho các class theo cách mình muốn, tùy thuộc cách chúng ta gán cho đối tượng trong function như nào mà Bean cho cái class đó sẽ như vậy. Tuy nhiên, khi chạy chương trình trên, bạn sẽ có lỗi: Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumedBạn biết vì sao chưa? Vì lúc này, chúng ta có tới 2 thằng Outfit trong IoC Container. @Component // Có component, nên IoC tạo ra 1 Outfit trong Containerpublic class Bikini implements Outfit { public void wear() {  System. out. println( Đã mặc Bikini ); }}@Configuration // Vì là Configuration, nên IoC sẽ chạy class này và tạo ra toàn bộ các @Bean trong nó. public class GirlConfig { @Bean // Có @Bean =&gt; tạo ra 1 Outfit là Naked trong Container.  public Outfit defaultOutfit(){  return new Naked();  }}class Girl{ // Lúc này IoC Container không biết nên inject thằng outfit nào vào đây.  @Autowired private Outfit outfit;}Có 2 hướng giải quyết: 1. @Primary: Đánh dấu cái Naked là ưu tiên. Như vậy khi có nhiều Bean dạng Outfit, nó sẽ luôn ưu tiên inject Naked trước. Đúng ý chúng ta. Khởi tạo ra Girl là phải Naked  @Bean @Primary public Outfit defaultOutfit(){  return new Naked(); }2. Qualifier: Khi bạn có nhiều Bean chung kiểu, gây bối rối cho Spring thì bạn phải đặt tên cho nó và chỉ định xem cái nào sẽ ở đâu @Bean( naked )public Outfit defaultOutfit(){ return new Naked();}@Component@Scope( prototype )public class Girl { @Autowired @Qualifier( naked ) private Outfit outfit; @Autowired private Accessories accessories; @Autowired private HairStyle hairStyle;}// Nhớ bỏ cái dòng lệnh này đi // Outfit outfit = context. getBean(Outfit. class);// System. out. println(outfit);// Outfit outfit2 = context. getBean(Outfit. class);// System. out. println(outfit == outfit2);// Thay bằng // context. getBean( naked , Outfit. class)// hoặc context. getBean( bikini , Outfit. class)Lời kết: Tới đây, mình đã giới thiệu xong với các bạn cách Spring Framework hoạt động và sử dụng nó trong code. Nắm được lý thuyết này cũng như các Annotation ở trên là bạn đã có thể code xoành xoạch cái Framework này rồi. Nhớ đón đọc các bài sau về hướng dẫn lập trình Spring boot nhé. Chúc các bạn học tập tốt và nhớ chia sẻ cho bạn bè học cùng ahehe :v "
    }, {
    "id": 37,
    "url": "https://loda.me/Giai-thich-Dependency-Injection-(DI)-va-Inversion-of-Control-(IOC)/",
    "title": "「Spring」Giải thích Dependency Injection (DI) và IoC bằng Ngọc Trinh",
    "body": "2019/03/23 - Heyzau, chào tất cả các bạn, hôm nay mình sẽ chia sẻ về 2 khái niệm gây nhức nhối và thương nhớ cho rất nhiều developer, Để làm việc được với Spring và hệ sinh thái quanh nó, thì việc đầu tiên, tiên quyết, duy nhất bạn cần làm đó là thấu hiểu định nghĩa của 2 cái này. Vậy chúng nó là cái gì, chúng ta sẽ đi vào chi tiết nhé. Dependency Injection (DI): Trong tài liệu có nói thế này:  Dependency Injection is a design pattern, … Thế thì bạn có thể hiểu nôm na nó là một phương pháp lập trình, là một thiết kế để bạn có được hiệu quả cao hơn khi code. Trước khi phương pháp này ra đời, bạn vẫn code bình thường, nhưng bây giờ có rồi, đi theo nó sẽ giúp ích nhiều hơn cho việc lập trình của bạn. Vậy cuối cùng Dependency Injection nó bảo chúng ta làm gì? 🙃 (nôm na nhiều mà quên mịa vấn đề chính) Mình sẽ giải thích cho các bạn qua một ví dụ như lày: public class Girl{  private Bikini outfit; // mỗi cô gái sẽ có một bộ bikini khi ra ngoài  public Girl(){   outfit = new Bikini(); // Khi bạn tạo ra 1 cô gái, bạn cho cô ta mặc Bikini chẳng hạn  }}Trước hết, qua đoạn code này, bạn sẽ thấy là khi bạn tạo ra một Girl, bạn sẽ tạo ra thêm 1 bộ Bikini đi kèm với cô gái đó. Lúc này, Bikini tồn tại mang ý nghĩa là dependency (phụ thuộc) của Girl. Khi khởi tạo thuộc tính như này, bạn vô tình tạo ra một điểm thắt nút trong chương trình của mình, giả sử, Girl muốn mặc một bộ Váy + Áo thun hở rốn hay không mặc gì thì sao? Bạn sẽ phải thay class Bikini thành SkirtWithTshirt(Váy với áo T-shirt) hay Naked (Trần như nhộng) ư? Hay nguy hiểm hơn, bộ đồ Bikini bị hỏng? (code lớp Bikini không hoạt động?) nó sẽ ảnh hưởng trực tiếp tới Girl. Vấn đề là ở đó, nguyên tắc là:  Các Class không nên phụ thuộc vào các kế thừa cấp thấp, mà nên phụ thuộc vào Abstraction (lớp trừu tượng). Nghe hơi khó hiểu. Bây giờ mình thay đoạn code như này: // Một interface cho việc ăn mặcpublic interface Outfit { public void wear();}// Một object cấp thấp, implement của Outfitspublic class Bikini implements Outfit { public void wear() {  System. out. println( Đã mặc Bikini ); }}// Bây giờ Girl chỉ phụ thuộc vào Outfit. nếu muốn thay đổi đồ của cô gái, chúng ta chỉ cần cho Outfit một thể hiện mới. public class Girl{  private Outfit outfit;  public Girl(){   outfit = new Bikini();  }}Tới đây, chúng ta mới chỉ Abtract hóa thuộc tính của Girl mà thôi, còn thực tế, Girl vẫn đang bị gắn với một bộ Bikini duy nhất. Vậy muốn thay đồ cho cô gái, bạn phải làm như nào. Phải sửa code thêm chút nữa: public class Girl{  private Outfit outfit;  public Girl(Outfit anything){   this. outfit = anything // Tạo ra một cô gái, với một món đồ tùy biến   // Không bị phụ thuộc quá nhiều vào thời điểm khởi tạo, hay code.   }}public class Main { public static void main(String[] args) {  Outfit bikini = new Bikini(); // Tạo ra đối tượng Bikini ở ngoài đối tượng  Girl ngocTrinh = new Girl(bikini); // Mặc nó vào cho cô gái khi tạo ra cô ấy.  }}Với đoạn code ở trên, chúng ta đã gần như tách được Bikini ra hoàn toàn khỏi Girl. điều này làm giảm sự phụ thuộc giữa Girl và Bikini. Mà tăng tính tùy biến, linh hoạt cho code. Bây giờ Girl sẽ hoạt động với Outfit mà thôi. Và Outfit ở đâu ra? Chúng ta tạo ra và đưa nó vào (Inject) cô gái Girl.  Khái niệm Dependency Injection từ đây mà ra~  Dependency Injection là việc các Object nên phụ thuộc vào các Abstract Class và thể hiện chi tiết của nó sẽ được Inject vào đối tượng lúc runtime. Bây giờ muốn Girl mặc gì khác, bạn chỉ cần tạo một Class kế thừa Outfit và Inject (dịch là Tiêm vào cũng được) nó vào Girl là xong! Các cách để Inject dependency vào một đối tượng có thể kể đến như sau:    Constructor Injection: Cái này chính là ví dụ của mình, tiêm dependency ngay vào Contructor cho tiện.     Setter Injection: Ồ, sao không chứ 😗 chúng ta học về Setter từ những bài học vỡ lòng rồi, quá hợp lý. Xài girl. setOutfit(new Naked()) 😈     Interface Injection: Mỗi Class muốn inject cái gì, thì phải implement một Interface có chứa một hàm inject(xx) (Gần như thay thế cho Setter ý bạn). Rồi bạn muốn inject gì đó thì gọi cái hàm inject(xx) ra. Cách này hơi dài và khó cho người mới.  Inversion of Control: Dependency Injection giúp chúng ta dễ dàng mở rộng code và giảm sự phụ thuộc giữa các dependency với nhau. Tuy nhiên, lúc này, khi code bạn sẽ phải kiêm thêm nhiệm vụ Inject dependency (tiêm sự phụ thuộc). Thử tưởng tượng một Class có hàng chục dependency thì bạn sẽ phải tự tay inject từng ý cái. Việc này lại dẫn tới khó khăn trong việc code, quản lý code và dependency public static void main(String[] args) {  Outfit bikini = new Bikini();  Accessories gucci = new GucciAccessories();  HairStyle hair = new KoreanHairStyle();  Girl ngocTrinh = new Girl(bikini, gucci, hair);}Giá như lúc này có thằng làm hộ được chúng ta việc này thì tốt biết mấy. Bây giờ giả sử, chúng ta định nghĩa trước toàn bộ các dependency có trong project, mô tả nó và tống nó vào 1 cái kho và giao cho một thằng tên là framework quản lý. Bất kỳ các Class nào khi khởi tạo, nó cần dependency gì, thì cái framework này sẽ tự tìm trong kho rồi inject vào đối tượng thay chúng ta. sẽ tiện hơn phải không? That it, chính nó, đó cũng chính là nguyên lý chính của Inversion of Control (IOC) - Đảo chiều sự điều khiển Nguyên văn Wiki:  Inversion of Control is a programming principle. flow of control within the application is not controlled by the application itself, but rather by the underlying framework. Khi đó, code chúng ta sẽ chỉ cần như này, để lấy ra 1 đối tượng: @Overridepublic void run(String. . . args) throws Exception {  Girl girl = context. getBean(Girl. class);}Đối với Java thì có một số Framework hỗ trợ chúng ta Inversion of Control (IOC), trong đó nổi bật có:  Spring framework Google GuiceSpring framework là một framework từ những ngày đầu, ra đời để hiện thực ý tưởng Inversion of Control (IOC), tuy nhiên, theo thời gian, Spring lớn mạnh và trở thành một hệ sinh thái rộng lớn phục vụ rất nhiều chức năng trên nền tàng IoC này. Google Guice ra đời sau và tập trung vào nhiệm vụ DI thôi. Mình sẽ hướng dẫn các bạn sử dụng Spring Framework tại đây nhé: Hướng dẫn lập trình Spring cho người mới bắt đầu Chỉ cần xem ví dụ trong code thì bạn sẽ hiểu vấn đề hơn rất nhiều. Lời kết: Tới đây, mình đã chia sẻ với các bạn các khái niệm về Dependency Injection và Inversion of Control. Bạn có thể biết được cách nó hình thành và vấn đề nó muốn giải quyết. Hi vọng các bạn sẽ có được góc nhìn gần gửi, thực tiễn và dễ hiểu. Còn nếu vẫn còn khúc mắc, thì hãy xem thêm chi tiết tại bài hướng dẫn sử dụng Spring nhé. Chúc các bạn học tốt và nhớ chia sẻ cho bạn học cùng. "
    }, {
    "id": 38,
    "url": "https://loda.me/Huong-dan-su-dung-Spring-Profiles/",
    "title": "「Spring-boot」Hướng dẫn sử dụng Spring Profiles",
    "body": "2019/03/22 - Spring Profiles là một core feature trong Spring Framework, cho phép chúng ta cấu hình ứng dụng, active/deactive Bean tùy theo môi trường. Một kịch bản thực tế:  Mình có 1 ứng dụng Spring Boot dùng để đọc báo, tuy nhiên mình phải hosting nó trên AWS. Vấn đề lúc này là khi đang viết code ở local thì mình cần kết nối với MySQL tại máy tính của mình, khi đưa lên AWS thì cần kết nối tới MySQL của AWS. Ngoài ra, chưa kể mình muốn cấu hình các biến cục bộ khác cho phù hợp với môi trường như log, redis, secret, v. v. . đặc biệt là việc một số phần trong code có thể thay đổi theo môi trường nữa. constants: service:  phase: ALPHA  debug: truespring: redis:  clusterUri: redis://abdheyj3847A@10. 127. 155. 18:7000 datasource:  username: xxx  password: none  url: jdbc:mysql://10. 127. 233. 12:2030/news?useSSL=false&amp;characterEncoding=UTF-8news: api:  channel-id: 1510354028  channel-secret: e17c94a02293b33a32629407b32b40a5  official-account-mid:  connection-timeout-secs: 20  .   .   . . rất rất nhiều config phải không :(((( Sớm nhận ra những khó khăn trong việc config khi xây dựng ứng dụng, nên Spring đã cho ra đời Spring Profiles để giải quyết các vấn đề này. 1. Tạo file config: Spring Profiles có sẵn trong Framework rồi nên bạn không cần thêm bất kì thư viện nào khác. Để sử dụng, các bạn tạo file config tại thư mục resources trong project. Mặc định Spring sẽ nhận các file có tên như sau: application. propertiesapplication. ymlapplication-{profile-name}. yml // . propertiesví dụ mình có 2 môi trường là local và aws, thì mình sẽ tạo ra các file như thế này: application. ymlapplication-local. ymlapplication-aws. ymlapplication-common. yml application là file config chính khai báo các enviroment.  application-local chỉ sử dụng khi chạy chương trình ở local application-aws chỉ sử dụng khi chạy ở AWS application-common là những config dùng chung, môi trường nào cũng cần. Bây giờ, mình sẽ khai báo trong từng file như sau: application. yml #application. yml---spring. profiles: localspring. profiles. include: common, local---spring. profiles: awsspring. profiles. include: common, aws---application-aws. yml spring: datasource:  username: xxx  password: xxx  url: jdbc:mysql://10. 127. 24. 12:2030/news?useSSL=false&amp;characterEncoding=UTF-8application-local. yml spring: datasource:  username: root  password:  url: jdbc:mysql://localhost:3306/news?useSSL=false&amp;characterEncoding=UTF-8logging: level:  org:   hibernate:    SQL: debugapplication-common. yml spring: jpa:  properties:   hibernate:    jdbc:     batch_size: 50     batch_versioned_data: true  hibernate:   ddl-auto: noneTadaa, xong, mình giải thích chút. bạn để ý trong file application. yml mình có khai báo 2 môi trường là local và aws. Tại mỗi môi trường sẽ include (bao gồm) các file config như kia. Khi mình kích hoạt aws chẳng hạn, Spring sẽ load tất cả config có trong application-common. yml và application-aws. yml. Rất tiện phải không :3 2. Kích hoạt config: Để sử dụng một Profiles bạn có các cách sau: #1: Sử dụng spring. profiles. active trong file application. properties hoặc application. yml spring. profiles. active=aws#2: Active trong code, trước khi chạy chương trình. @Configurationpublic class ApplicationInitializer  implements WebApplicationInitializer {   @Override  public void onStartup(ServletContext servletContext) throws ServletException {    servletContext. setInitParameter(      spring. profiles. active ,  aws );  }}hoặc @Autowiredprivate ConfigurableEnvironment env;. . . env. setActiveProfiles( aws );hoặc SpringApplication application = new SpringApplication(SpringBootProfilesApplication. class);ConfigurableEnvironment environment = new StandardEnvironment();environment. setActiveProfiles( aws );application. setEnvironment(environment);application. run(args);Mình không khuyến khích cả 3 cách này ==! #3: Sử dụng JVM System Parameter (nên dùng) -Dspring. profiles. active=aws#4: Environment Variable (Unix) (nên dùng) export SPRING_PROFILES_ACTIVE=awsNếu ai sử dụng Intellij IDEA thì có thể config ngay trong IDE như thế này, mỗi lần chạy nó tự active cho mình. 3. Cách sử dụng @Profile: Khi đã có Profile rồi, ngoài các biến toàn cục được thay đổi theo môi trường, bạn cũng có thể toàn quyền quyết định xem trong code rằng Bean hay class nào sẽ được quyền chạy ở môi trường nào. Bằng cách sử dụng annotation @Profile // Bean này Spring chỉ khởi tạo và quản lý khi môi trường là `local`@Component@Profile( local )public class LocalDatasourceConfigNgoài ra bạn có thể sử dụng toàn tử logic ở đây, ví dụ: // Bean này Spring chỉ khởi tạo và quản lý khi môi trường là những môi trường không phải là `local`@Component@Profile( !local )public class LocalDatasourceConfigOkiee lahhh, thế là mình đã giới thiệu xong với các bạn Spring Profiles, Đây là một tính năng cực kì cực kì hữu ích, hi vọng các bạn hiểu và nắm được kiến thức, áp dụng vào sản phẩm của chính mình. Chúc các bạn thành công! Đứng quên like và chia sẻ cho bạn bè cùng biết nhé, ahihi :3 "
    }, {
    "id": 39,
    "url": "https://loda.me/Java-basic-4-Nhap-xuat-du-lieu/",
    "title": "「Java basic #4」Nhập xuất dữ liệu trong Java",
    "body": "2019/03/22 - Xin chào các bạn, mào chừng các bạn đã quay trở lại với series Thành thạo Java Basic trong 2 tuần. Mình muốn nhắc lại rằng mọi bài viết trong series này đều liên quan tới nhau, và nó không phải là bài viết “ăn liền” như các bài viết hướng dẫn về Java khác, vì thế hãy cố gắng theo dõi từ đầu để có thể học Java một cách hiểu quả nhất. Mình đi vào bài ngày hôm nay luôn nào :v Nhập xuất từ bàn phím: Hẳn từ những ngày đầu biết sử dụng máy tính và phần mềm, các bạn không thể nào thiếu được cái Keyboard của mình 😂 Quả đúng là như vậy, bàn phím là thứ công cụ giúp chúng ta giao tiếp với máy tính, nên nếu Java không hỗ trợ cái này thì quả là một thiếu sót lớn. Quay trở lại ví dụ của Bài #3. Chương trình kiểm tra tam giác của chúng ta còn thiếu sự linh động, do phải điều chỉnh các biến a,b,c trực tiếp trong code. Bây giờ chúng ta sẽ upgrade bài toán một chút: “Nhận vào 3 số nguyên a,b,c từ bàn phím và kiểm tra nó là tam giác gì?” Cùng xem cách mình thực hiện, và mình sẽ giải thích ở dưới: public class Calculation {  public static void main(String[] args) {    // Chúng ta khai báo 3 biến a,b,c không có giá trị.     int a, b, c;        //Khai báo đối tượng Scanner, giúp chúng ta nhận thông tin từ keyboard     Scanner sc = new Scanner(System. in);    System. out. print( Nhập a:  ); //print thay vì println, nó sẽ in ra, nhưng không xuống dòng    a = sc. nextInt(); // sc. nextInt() là cách để lấy giá trị từ bàn phím, nó sẽ chờ tới khi chúng ta nhập một số.     System. out. print( Nhập b:  );    b = sc. nextInt();     System. out. print( Nhập c:  );    c = sc. nextInt();    // In các giá trị ra màn hình    System. out. println( a =   + a +  , b =   + b +  , c =   + c);    // Đây là phép cộng String mình đã nói trong Bài #1. }Khi chạy chương trình này, nó sẽ dừng lại sau khi in ra Nhập a như thế này: Vì sao? 😕 Vì cái dòng lệnh này a = sc. nextInt(). Nó sẽ chờ cho tới khi bạn nhập 1 số nguyên và gõ Enter thì thôi. Giả sử mình nhập 5 Chương trình lại tiếp tục chạy cho tới khi gặp câu lệnh sc. nextInt() tiếp theo. Và cứ tiếp tục như vậy cho tới dòng lệnh cuối cùng.  Từ đây, các bạn có thể hiểu là đối tượng Scanner đã làm nhiệm vụ là nhận dữ liệu người dùng nhập từ bàn phím, và gán nó vào biến, bằng câu lệnh nextInt. Bây giờ quay trở ngược lên trên 1 chút, ở câu lệnh: Scanner sc = new Scanner(System. in);các bạn sẽ thấy một khái niệm là new. cái này thì [Bài #5][link-bai5] mình sẽ nói chi tiết, còn ở đây thì bạn hiểu nó được sử dụng để tạo ra 1 đối tượng Scanner. Mà từ đó các bạn mới nhận dữ liệu từ bàn phím được. Các phương thức nhập xuất: Tới đây, bạn đã có thể nhập xuất dữ liệu int từ bàn phím rồi, thế còn double hay String thì như thế lào :3 cái này bạn nào thực hành đoạn code trên rồi thì sẽ nhìn thấy ngay là Scanner có một loạt các hàm hỗ trợ như sau:  next(): Nhận vào một String token (nhận vào 1 từ đầu tiên thay cả câu) nextInt(): Nhận vào một số int nextLong(): Nhận vào một số long nextFloat(): Nhận vào một số float nextDouble(): Nhận vào một số double sc. nextLine(): Nhận vào một chuỗi String (Cả 1 câu) nextByte(): Nhận vào một byte nextBoolean(): Nhận vào một booleanCác hàm trên bạn hiểu nguyên lý là nó đều sẽ chờ cho tới khi bạn nhập kiểu dữ liệu nó muốn vào. Có next() và nextLine() khá đặc biệt, mình sẽ ví dụ: Scanner sc = new Scanner(System. in); //Tạo đối tượng ScannerSystem. out. print( Nhập gì đó:  );String a = sc. nextLine(); // nhận vào 1 stringSystem. out. println( Bạn vừa nhập:  +a);System. out. print( Nhập thêm gì đi:  );String b = sc. next(); // cũng nhận vào 1 StringSystem. out. println( Bạn vừa nhập:  +b);Chúng ta chạy chương trình để xem nó ra sao: nextLine thì nhận vào cả 1 chuỗi dài String, cho tới khi bạn nhấn Enter. Còn next dù bạn có nhập dài như nào, nó cũng nhận 1 từ đầu tiên thôi. Okie, giờ mình sử dụng các kiến thức này để nâng cấp bài tập kiểm tra tam giác ở Bài #3 nhé. class Calculation { public static void main(String[] args) {  int a, b, c; // Khai báo 3 biến int, không cần giá trị.   Scanner sc = new Scanner(System. in); // Tạo đối tượng Scanner  System. out. print( Nhập a:  );  a = sc. nextInt();  System. out. print( Nhập b:  );  b = sc. nextInt();  System. out. print( Nhập c:  );  c = sc. nextInt();  if (laTamgiac(a,b,c)){   System. out. println( Là tam giác! );   if(laTamgiacDeu(a,b,c)){    System. out. println( Và còn đều nữa! );    // Là tam giác đều thì không cần kiếm tra điều kiện còn lại nữa.    }else {    if (laTamgiacVuong(a, b, c)) {     System. out. println( Và còn vuông nữa! );     // Không thể xảy ra vuông cân. Vì chúng ta đầu vào chỉ là số nguyên.      // Còn muốn đầy đủ, bạn phải kiểm tra trường hợp vừa vuông vừa cân nữa.     }    if (laTamgiacCan(a, b, c)) {     System. out. println( Và còn cân nữa! );    }   }  }else{   System. out. println( Không phải là tam giác! );  } } public static boolean laTamgiac(int a, int b, int c) {  if ((a + b) &gt; c &amp;&amp; (a + c) &gt; b &amp;&amp; (b + c) &gt; a) {   // Tam giacs: tổng 2 cạnh phải lớn hơn cạnh còn lại   return true;  } else {   return false;  } } public static boolean laTamgiacVuong(int a, int b, int c){  if ((a*a + b*b) == c*c || (a*a + c*c) == b*b || (b*b + c*c) == a*a) {   // Là tam giác vuông nếu có 1 trong các đièu kiện thoả mãn pythagore.    return true;  } else {   return false;  } } public static boolean laTamgiacCan(int a, int b, int c){  if (a == b || b == c || c == a) {   return true;  }else{   return false;  } } public static boolean laTamgiacDeu(int a, int b, int c){  if (a == b &amp;&amp; b == c) {   return true;  }else{   return false;  } }}Kết quả: 1 Thứ hay ho, nếu bạn nhập liên tục các số như này: Nó vẫn hiểu! và có vẻ như nó bỏ qua luôn các bước nhập b và nhập c Vì sao? tới đây mình muốn nói kỹ hơn về bản chất của việc nhập vào bàn phím. Bản chất của next: Bạn để ý là các hàm lấy giá trị từ bàn phím đều có chữ next. Bây giờ bạn chạy cho mình ví dụ này, bạn sẽ hiểu: public static void main(String[] args) {  int a,b,c;  Scanner sc = new Scanner(System. in); // Tạo đối tượng Scanner  System. out. print( Nhập a:  );  a = sc. nextInt();  b = sc. nextInt();  c = sc. nextInt();  System. out. println( a =  +a);  System. out. println( b =  +b);  System. out. println( c =  +c);} Bạn sẽ thấy là, nó đưa tuần tự các giá trị hiện có trên bàn phím vào các biến. bản chất của chữ next chính là tuần tự. Nó sẽ chờ bạn nhập nếu không có giá trị gì trên màn hình, nhưng nếu đã có sẵn giá trị rồi, nó sẽ ghi nhớ trong bộ đệm và khi gặp hàm nextInt() nó không chờ nữa, mà nó lấy luôn cái giá trị còn thừa ra, chưa sử dụng đến để gắn luôn vào biến 😂 Nhìn như như này cho dễ hiểu: public static void main(String[] args) {  int a,b,c;  Scanner sc = new Scanner(System. in); // Tạo đối tượng Scanner  System. out. print( Nhập a:  );  a = sc. nextInt(); // Chờ bạn nhập.   // bạn nhập: 5 6 7 8 9 10  // bộ đệm = 5 6 7 8 9 10  // lấy 5 ra, gắn vào a  // bộ đệm còn: 6 7 8 9 10  b = sc. nextInt(); // gặp lệnh nextInt()  // thấy bộ đệm còn, lấy 6 ra, gắn vào b  // bộ đệm còn: 7 8 9 10  c = sc. nextInt(); // gặp lệnh nextInt()  // thấy bộ đệm còn thừa, lấy 7 ra, gắn vào b  // bộ đệm còn: 8 9 10  System. out. println( a =  +a); // in a  System. out. println( b =  +b); // in b  System. out. println( c =  +c); // in c}Inpụt/ outpụt từ File: Để đề phòng thế giới bị phá hoại… ==! lại xàm r Để cho thuận tiện trong việc đọc ghi, thì ngoài bàn phím, một trong những yêu cầu quan trọng khi lập trình đó là nhập xuất dữ liệu từ File, phần này sẽ không khác nhiều với từ bàn phím đâu các bạn, mình sẽ hướng dẫn. Tại thư mục gốc của project, bạn click New &gt; File. Tạo 1 tệp tên là input. txt. Như hình: Bạn mở file ra và nhập dữ liệu vào dòng đầu tiên như lày: Sau đó vào code ở trên, và sửa 1 dòng như thế này: public static void main(String[] args) throws FileNotFoundException { // Thêm cái này vào đây  int a,b,c;  Scanner sc = new Scanner(new File( input. txt )); // Tạo đối tượng Scanner đọc tới cái file vừa tạo  System. out. print( Nhập a:  );  a = sc. nextInt();   b = sc. nextInt();   c = sc. nextInt();  System. out. println( a =  +a); // in a  System. out. println( b =  +b); // in b  System. out. println( c =  +c); // in c}// Kết quả chạy:// Nhập a: a = 5// b = 7// c = 8Vậy thoai, rất đươn giản, tuy nhiên sẽ có phần bạn sẽ chưa biết đó là đoạn throws FileNotFoundException. Cái này thì phải bài sau sau nữa mình mới nói chi tiết được. Ở đây thì bạn hiểu nó là lỗi có thể xảy ra, nếu nó không tìm thấy file input. txt thì nó sẽ xảy ra cái lỗi kia. Chúng ta sẽ xử lý lỗi đó sau, hiện tại thì nếu bạn nhập đúng tên File thì không thể lỗi được :))) Chu choa mọa ơi, bài này nói xíu mà dài gớm :))) nhưng về cơn bản, nhập xuất dữ liệu nó là như vậy đấy các bạn 😂 Chúc các bạn học tập hiệu quả! và chớ quên share cho bạn bè học cùng :3 "
    }, {
    "id": 40,
    "url": "https://loda.me/ThanosJS-lam-bien-mat-1-nua-DU-LIEU-may-ban-voi-1-dong-lenh/",
    "title": "ThanosJS - làm biến mất 1 nửa DỮ LIỆU PC với 1 dòng lệnh",
    "body": "2019/03/22 - Nhìn hình thì các bạn cũng biết phải làm gì rồi chứ :))) Bưng, nửa số files trong máy bạn biến mất. Nếu chưa, thì làm như mình hướng dẫn nhé :3 Cài đặt: Trước hết bạn cần cài Ruby Gem. Windows: https://rubyinstaller. org/downloads/Unix: sudo apt-get install ruby-devXóa nửa dân số: Lắp ngọc Power gem install powerLắp ngọc Reality gem install realityLắp ngọc Mind gem install mindLắp ngọc Space gem install spaceLắp ngọc Time gem install timeLắp ngọc Soul gem install soulBúng tay thanos snap-fingers --with-gloveChúc bạn khôi phục dữ liệu may mắn! "
    }, {
    "id": 41,
    "url": "https://loda.me/Minh-da-lam-xe-tu-lai-nhu-the-nao/",
    "title": "Mình đã làm xe tự lái như thế nào?",
    "body": "2019/03/22 - Đôi nét về Xe tự hành: Chắc hẳn những cụm từ như “Xe tự hành” (hay “Xe tự lái”) đã không còn xa lạ đối với những người quan tâm tới công nghệ trong suốt thời gian qua. Đã có rất nhiều tập đoàn, công ty lớn tham gia vào vào cuộc đua nghiên cứu xe tự hành này, tiêu biểu có thể kể tới như Uber, Apple, Ford, Honda, BWM, Liên minh Renault – Nissan – Mitsubishi,. . Theo số liệu báo cáo từ KPMG thì tổng số tiền đầu tư vào lĩnh vực này trong 05 năm vừa qua đã đạt tới con số hơn 50 tỷ USD (ờ hớ ờ hớ) Cho những bạn chưa biết, thì “xe tự hành” có thể hiểu là ôtô có khả năng hoạt động mà không cần đến sự điều khiển hay can thiệp của con người. Nếu xe tự hành được nghiên cứu và áp dụng thành công thì những lợi ích mà nó đem lại sẽ có tác động rất tích cực đến chất lượng đời sống của con người như: giảm tỷ lệ tai nạn giao thông do bất cẩn của người lái, giảm thiểu chi phí sửa chữa ô tô; hỗ trợ người tàn tật, người già di chuyển dễ dàng, chủ động hơn. Hành trình đáng nhớ với “Cuộc đua số”: Đây là chân dung chiếc xe tự hành mini của chúng mình. Xe được xây dựng trên tỉ lệ 1:20 so với xe thật, có kích thước chiều dài khoảng 40cm và chiều cao 30cm. Em xe này có tốc độ chạy tối đa 25 km/h, có thể leo trèo bãi đất, bãi cát, leo dốc 45 độ, lội nước sâu tầm 10 cm, lội tuyết, sình lầy (cũng khá ngầu phải không :P)   Chi tiết hơn thì chiếc xe gồm có:  Động cơ điều khiển bánh Vi mạch Jetson TX1 Camera Cảm biến vật cản Màn hình led và các phím chức năng Dây nối tín hiệu cho mạch và dây nguồn cho động cơ/mạchSau đây, mình sẽ chia sẻ qua một chút về quá trình team mình lập trình chiếc xe này và đi vào từng bài toán mà bọn mình cần giải quyết. Thật đáng tiếc là cuộc thi đã trôi qua được 1 năm, và source code mình đã gửi lại cho ban tổ chức, cũng như không còn lưu giữ gì về nó :’( mình sẽ chia sẻ hướng giải quyết vấn đề. còn source code sẽ tự bổ sung lại dần dần sau này. Xác định 2 biên đường: Để xe có thể đi đúng thì cần xác định 2 biên đường để đảm bảo xe luôn đi trong đó. Đây là một bài toán xử lý ảnh cơ bản vì 2 làn đường có màu trắng trên nền đen và bỏ qua yếu tố ngoại cảnh như nhiễu hạt hay vật cản. Ngoài ra, xe chỉ cần xác định đoạn đường trước nó không xa, nên mình cắt 1 nửa ảnh, lấy đoạn đường phía dưới để xử lý. Mình đã sử dụng lọc màu trên kênh HSV để làm nổi bật các đường màu trắng, sau đó sử dụng thuật toán Canny để cho ra biên ảnh. Từ Canny mình có thể xác định được các đường thẳng trong ảnh =&gt; chính là các làn đường trong ảnh.   Tham khảo thuật toán Canny tại đây. Xác định tâm đường: Khi đã xác định được 2 làn đường, việc xác định tâm đường sẽ đơn giản với đoạn đường thẳng đó là lấy trung điểm của 2 làn đường. Tại mỗi lần di chuyển, hình ảnh camera bắt được sẽ thay đổi theo thời gian nên tâm đường sẽ bị dịch chuyển, nhưng phải nằm trong giới hạn thay đổi nhất định, tâm đường mới không được quá lệch với tâm đường trước, thuật toán của bọn mình sẽ đặt ra 1 giới hạn để tránh tâm đường thay đổi đột ngột. Tuy nhiên, có trường hợp đặc biệt là đoạn đường cong. Sẽ không thể lấy trung điểm nữa mà phải sử dụng thuật toán hồi quy để suy diễn từ các tâm đường trước đó. Đây là thuật toán chính để giúp xe luôn đi trong đường quy định. Mình sẽ bổ sung thuật toán này sớm nhất khi nhớ lại source code huhu. Xe di chuyển: Khi đã xác định được tâm đường, thì việc cho xe di chuyển chỉ là đi theo cái tâm ý, và cứ nhăm nhăm mà đi thôi. Chỉ khó ở việc cho xe rẽ ở đoạn đường cong, sẽ phải điều chỉnh độ nghiêng của bánh lớn hơn 2 lần. Tốc độ di chuyển giảm xuống khoảng 0. 65 Xác định vật cản: Trên đường đi, vật cản được quy định là khối hộp màu xanh và đỏ điều này khá dễ dàng để có thể nhận biết, chỉ 1 vài phép biến đổi ảnh đơn giản như Color Filter, Convex Hull là sẽ ra. Thuật toán bạn tham khảo tại đây tại đây   Xác định biển báo rẽ đường: Trong phần xác định biển báo rẽ trái hoặc rẽ phải. Mình sẽ dụng màu xanh nước biển là bộ lọc, sau đó xác định Contour và bao viền biển báo. Cái này cần ốp machine learning mạnh mẽ vào :v Khi đã biết được biển báo ở đâu, mình sẽ sử dụng thuật toán trích đặc trưng của biển báo là HOG và đưa vào một bộ nhận dạng đã được huấn luyện từ trước là SVM để xác định xem biển báo là gì =&gt; Lúc này sẽ biết được biển báo đó là rẽ trái hay rẽ phải và điều khiển xe theo hướng đó   Trên đây là toàn bộ những chia sẻ của mình về việc mình đã được tham gia lập trình một chiếc Xe tự hành ở level “đơn giản” như thế nào. Hy vọng là trong tương lai sẽ không còn là dạng “mô hình” hay “level đơn giản” nữa :D Một lần nữa xin lỗi bạn đọc vì không có source code ở đây, nhưng mình sẽ bổ sung trong thời gian sớm nhất có thể. ít ra trong bài viết có những keywords khá quan trọng nếu bạn muốn tìm hiểu :D "
    }, {
    "id": 42,
    "url": "https://loda.me/Huong-dan-su-dung-Lombok-giup-code-Java-nhanh-hon-69/",
    "title": "「General」Hướng dẫn sử dụng Lombok, giúp code Java nhanh hơn 69%",
    "body": "2019/03/22 - Lombok?: Lombok là một thư viện, một plugin, giúp chúng ta giảm thiểu các đoạn code thừa (boilerplate) bằng cách tự động sinh ra các hàm Get, Set, Constructor, v. v. . Chắc hẳn ai là Java Developer chinh chiến nhiều năm thì đều ngán ngẩm với việc ngồi viết những hàm Get/Set, Các Constructor có tham số lặp đi lặp lại, mặc dù các IDE đều hỗ trợ Generate tự động, tuy nhiên khi Project lớn, việc quản lý hàng chục function như vậy trông rất rối mắt và thừa thãi. Từ đây, vị cứu tinh của chúng ta, **Lombok** ra đời :3 Với tiêu chí giúp developer tập trung vào tầng nghiệp vụ và logic thay vì mất thời gian làm những việc “thừa thãi”. Không những làm cho code sáng sửa mà còn trông rất hợp lý, dễ quản lý hơn (Per con ông phệch). Sức mạnh của Lombok không chỉ dừng ở việc Get/Set mà còn nhiều khả năng tuyệt vời khác nữa, mình cũng tìm hiểu ở dưới nhé. Cài đặt: Để sử dụng được Lombok bạn cần có 2 điều kiện sau:  Thư viện lombok trong project của bạn IDE cao cấp, hỗ trợ lombok (IntelliJ IDEA, Eclipse, . . )Chúng ta đi vào từng phần: Bước 1Cách nhanh nhất để đưa 1 lib java vào project của bạn là sử dụng Maven, hoặc Gradle :3 Maven &lt;!-- https://mvnrepository. com/artifact/org. projectlombok/lombok --&gt;&lt;dependency&gt;  &lt;groupId&gt;org. projectlombok&lt;/groupId&gt;  &lt;artifactId&gt;lombok&lt;/artifactId&gt;  &lt;version&gt;1. 18. 4&lt;/version&gt;  &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;Gradle // https://mvnrepository. com/artifact/org. projectlombok/lombokprovided group: 'org. projectlombok', name: 'lombok', version: '1. 18. 4'Nếu bạn chưa biết Maven hay Gradle là gì thì xem tại đây nhé Bước 2Góc giải thích nhẹ (Bạn có thể bỏ qua và xuống phần cài đặt luôn)Bạn cần cài Lombok plugin cho IDE của bạn, vì sao? Bạn hiểu là IDE chỉ nhìn thấy những dòng code của bạn hiện tại, và từ đó tham chiếu tới nó, bây giờ bạn không viết hàm Get/Set nữa, thì nó không nhìn thấy, và điều gì sẽ xảy ra nếu bạn viết user. getName() trong khi function getName() không hề tồn tại :v oh siệc man. Thông báo lỗi đỏ lè. Bản thân Lombok là một thư viện, nó sẽ tự động thêm Get/Set khi project của bạn được build. Tức tự viết thêm code vào class đó trước khi nó thành file jar. Nên để IDE hiểu rằng class User đã có các hàm Get/ Set/ Constructor này rồi, hiển thị nó cho tao, thì bạn phải cài Lombok Plugin Cài đặt Lombok cho IntelliJ IDEAMình sử dụng IntelliJ IDEA nha mọi người, Eclipse cũng tương tự nhé (khác mỗi chỗ cài đặt :”) ) Các bạn vào File &gt; Setting &gt; Plugins . . Search: “Lombok” Chọn Lombok Plugin và nhấn Install Chớ quên Apply nhé! Tadaaa, Chưa xong đâu ==! nếu là lần đầu, bạn sẽ phải làm thêm 2 bước này nữa. Restart IDE &gt; File &gt; Setting &gt; Other Setting &gt; Lombok Plugin &gt; Enable Lombok plugin for this project &gt; Apply File &gt; Setting &gt; Build, Execution, Deployment &gt; Complier &gt; Annotation Processors &gt; Apply Rồi, chính thức là xong! Bây giờ project của bạn đã có Lombok Sử dụng Lombok: Lombok dùng Annotation để khai báo với trình biên dịch. @DataNhìn lại vào ví dụ đầu tiên, 2 đoạn code này là tương đương.  @Data sẽ có tác dụng generate ra Constructor rỗng hoặc có tham số theo yêu cầu (cái này sẽ nói sau), toàn bộ Get/Set, hàm equals, hashCode, toString() Khi bạn đã đánh dấu 1 class là @Data, thì tại bất cứ đâu trong project. Khi sử dụng tới class này, nó sẽ tự có các function đã generate mà không cần code thêm bất kì dòng nào: Constructor với @NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructorTrong trường hợp bạn muốn định nghĩa các Constructor theo ý mình, thì Lombok hỗ trợ 3 Annotation:  @NoArgsConstructor: Hàm khởi tạo rỗng, đã đề cập ở trên @AllArgsConstructor: Hàm khởi tạo chứa tất cả thuộc tính, ví dụ Champion(String name, String type) @RequiredArgsConstructor: Hàm khởi tạo theo yêu cầu. Bạn chỉ muốn hàm khởi tạo có vài thuộc tính do bạn chọn thôi, thì bạn thêm final trước thuộc tính trong class, nó sẽ tự sinh ra Constructor như thế. @RequiredArgsConstructorpublic class Champion { private final String name; private String type;// @RequiredArgsConstructor + final đồng nghĩa với Constructor như thế này. // public Champion(String name) {//  this. name = name;// }}@RequiredArgsConstructor là một vũ khí cực kì, cực kì lợi hại nhé :3 Sau này khi tới các bài về Spring và nâng cao hơn, mình sẽ cho các bạn thấy tác dụng kì riệu của e nó :3 @Getter/@SetterKhi bạn chỉ muốn generate mỗi Get/Set thôi và không muốn dùng @Data vì nó quá nhiều chức năng, thì có thể xài 2 câu thần chú @Getter và @Setter @Getter@Setterpublic class Champion { private String name; private String type;}Nâng cao hơn, bạn chỉ muốn xài Get/Set cho 1 thuộc tính thì sao? thì như này nè :3 public class Champion { // Tạo ra get/set cho name @Getter @Setter private String name; // Tạo ra protected setType(String) thay vì public @Setter(AccessLevel. PROTECTED) private String type;}@ToString và @EqualsAndHashCodeNhìn tên các bạn cũng đoán ra phải không, để tý thì đây đều là các chức năng riêng rẽ mà đã được @Data gom lại thành 1.  @ToString: Tạo ra hàm toString() từ thuộc tính class.  @EqualsAndHashCode: Tạo ra hàm equals và hashCodeCái này ví dụ ở đầu bài viết mình đã chỉ ra rồi, phần này có một vấn đề thôi, là nếu bạn không muốn làm toString hay equals KHÔNG tác động tới 1 thuộc tính nào đó, thì làm như nào? Lúc này chúng ta sẽ dùng tới Exclude @ToStringpublic class Champion { private String name; @ToString. Exclude private String type; // Thuộc tính type đã bị bỏ qua// @Override// public String toString() {//  return  Champion{  +  name='  + name + '\'' + '}';// }}@BuilderChắc hẳn ai cũng ngại khi viết 1 class Builder cổ điển phải không, tự dưng phải tạo thêm 1 class nữa, gấp đôi số lượng thuộc tính khai báo, gấp đôi số hàm cần viết huhu. :”(( Và một lần nữa, vị cứu tinh Lombok lại đến và lau đi nước mắt của loda với @Builder. Đây là một chức năng đặc biệt dành cho người lười biếng (như mình). Put @Data@Builderpublic class Champion { private String name; private String type;}Then Champion loda = Champion. builder()    . name( loda )    . type( Support )    . build();Lời kết: Cảm ơn chúa, cảm ơn Reinier Zwitserloot và cộng đồng mã nguồn mở đã cứu rỗi lấy linh hồn của những thánh lười như loda :3 Lombok còn rất nhiều tính năng hay ho, mình đã giới thiệu các phần thông dụng nhất mà project nào cũng sẽ cần đến và cách sử dụng nó, khi tới các bài viết về các framework của Java, mình sẽ đề cập thêm các yếu tố nâng cao hơn của nó. Còn bạn nào muốn tìm hiểu thêm thì hãy vào trang chủ của Lombok. Cảm ơn các bạn đã đọc hết bài viết, theo dõi loda để cập nhật các bài viết mới và thú vị nhé! Và đừng quên chia sẻ cho bạn bè kaka :v "
    }, {
    "id": 43,
    "url": "https://loda.me/Java-basic-3-Ham-va-cau-lenh-dieu-kien/",
    "title": "「Java basic #3」Hàm và câu lệnh điều kiện",
    "body": "2019/03/21 - Helluuuuuu eveerybody, Lại là mình loda đây. Trong bài này chúng ta sẽ đi tìm hiểu các câu lệnh rẽ nhánh hay điều kiện trong Java, từ đó giúp chúng ta điều hướng được chương trình theo ý muốn của mình. Cùng vào bài luôn nhé. #1 Câu lệnh rẽ nhánh: if: Các bạn nhìn qua ví dụ này: public static void main(String[] args){  // khai bao so nguyen  int a = 10;    // Kiểm tra xem a có bằng 9 không  if(a == 9){    // nếu bằng 9, in ra màn hình  Hello     System. out. println( Hello );  }  // Kiểm tra xem a có bằng 9 không  if(a == 10){    // nếu bằng 10, in ra màn hình  World     System. out. println( World );  }// Kết quả trên màn hình: // World}Nếu các bạn chạy ví dụ ở trên thì sẽ thấy kết quả trên màn hình chỉ có chữ World. Lí do thì bạn biết rồi phải không 😗 Cái mình muốn các bạn để ý ở đây là cái dấu ==. Sao lại == 🤔 mà không phải = Thì các cần biết như sau, câu lệnh if là một câu lệnh điều kiện, và nhận vào là một điều kiện true hoặc false. Có cú pháp như sau: if ([điều kiện]){  // Thực hiện đoạn code nếu [điều kiện] là `true`. Nếu `false` bỏ qa đi xuống dưới. }// Tiếp tục thực hiện đoạn code phía dướiLúc này nếu bạn viết if(a = 5) như Sách giáo khoa toán thì sẽ nhận về kết cục cay đắng 😢 vì trong Bài #2 mình có nói, dấu = là phép gán. Tức là gán cho a giá trị bằng 5 chứ không phải ý nghĩa là so sánh a với 5 để mà trả về là true hay false nữa. Vậy đấy, nên để so sánh bạn cần dùng toán tử quan hệ mình liệt kê dưới đây:  ==: Kiểm tra 2 toán hạng có bằng nhau không? (if(a==b)) !=: Kiểm tra 2 toán hạng có khác nhau không? (if(a!=b)) &gt;: Kiểm tra toàn hạng A có lớn hơn B không? (if(a&gt;b)) &lt;: Kiểm tra toàn hạng A có nhỏ hơn B không? (if(a&lt;b)) &gt;=: Kiểm tra toàn hạng A có lớn hơn hoặc bằng B không? (if(a&gt;=b)) &lt;=: Kiểm tra toàn hạng A có nhỏ hơn hoặc bằng B không? (if(a&lt;=b))Tất cả toán tử quan hệ ở trên, khi thực hiện xong nó sẽ trả về là kiểu boolean, nên bạn có thể gán nó vào một biến bất kỳ, như lày: int a = 5;int b = 6;boolean result = a == b; // falseSystem. out. println( Result:   + result);// Kết quả in ra trên màn hình: //  Result: false if(result){ // viết tắt của if(result == true)  System. out. println( Result is true );}Đến đây, có thể nói câu lệnh if thực chất nhận vào một giá trị boolean. else: Tiếp theo, chúng ta tới với dạng đầy đủ của if chính là cấu trúc if else. if ([điều kiện]){  // Thực hiện đoạn code nếu [điều kiện] là `true`. }else{  // Thực hiện đoạn code trong này nếu [điều kiện] là `false`}//Các đoạn code ở dưới thực hiện bình thường sau khi if hoặc else diễn raVí dụ: int a = 5;if ( (a + 2) == 7 ){  System. out. println( Bằng 7 );  // Sử dụng biến `a` ở ngay trong scope {} của `if`,, như bài #2 mình có nói, biến được sử dụng trong các scope con hoặc bằng cấp  System. out. println( Giá trị lúc này của a =   + a);}else{  System. out. println( Khác 7 );  System. out. println( Giá trị lúc này của a =   + a);  int b = 7; // Tạo ra 1 biến b trong else}b = 50; // Lỗi, không biết b là gì, vì b ở scope nhỏ hơn, bên ngoài không hiểu. Ví dụ trên mình vừa cho các bạn thấy cách sử dụng if else vừa củng cố lại kiến thức của Bài #2 luôn. Toán tử logic: Toán tử logic là những toán tử giúp chúng ta kết hợp nhiều [điều kiện] lại với nhau. Ví dụ mình nói:  Nếu ab = 3 VÀ ac = 4 VÀ bc = 5 thì abc là tam giác vuông  Thì trong code cần viết chương trình như thế nào? Cách 1: Sử dụng if thông thường. int ab = 3;int ac = 4;int bc = 5;if(ab == 3){  if(ac == 4){    if(bc == 5){      System. out. println( abc là tam giác cực vuông );    }  }}Ohhh loooo, my eyes 😱 tôi đang nhìn cái rì thế này. Một chương trình là có vài trăm cái điều kiện chắc chết. Cách 2: Sử dụng if và toán tử logic int ab = 3;int ac = 4;int bc = 5;// Nếu ab = 3 VÀ ac = 4 VÀ bc = 5if(ab == 3 &amp;&amp; ac == 4 &amp;&amp; bc==5){   // thì abc là tam giác vuông  System. out. println( abc là tam giác cực vuông );}Rất gì và này nọ phải không :))) đọc mồm sao, viết code y xì vậy, quá hay, quá tuyệt vời. 😱😜 Các bạn nhìn ví dụ cũng đoán ra &amp;&amp; chính là toán tử logic đại diện cho khái niệm AND. Chúng ta có tất cả các loại toán tử logic như sau:  &amp;&amp;: AND ||: OR !: NOTMục tiêu của các toán tử logic là tác động lên các biểu thức boolean để cho ra một biến boolean mới. Phép AND (&amp;&amp;): Phép &amp;&amp; hoạt động theo nguyên tắc, chỉ cần có 1 cái sai, thì tất cả đều sai hay Tất cả đều phải đúng, mới là đúng Nếu  A đúng và B đúng và C sai thì kết quả vẫn là sai  // Bạn chạy thử xem nó đi vào phần nào nhéif(true &amp;&amp; true &amp;&amp; true &amp;&amp; false){  System. out. println( true );}else{  System. out. println( false );}Phép OR (||): Phép || thì rất dễ dãi, Chỉ 1 cái đúng là đụ // Bạn chạy thử xem nó đi vào phần nào nhéif(false || false || true || false){  System. out. println( true );}else{  System. out. println( false );}Phép NOT (!): Phép ! làm phủ định giá trị của biểu thức, nếu nó đang true thì biến nó thành false và ngược lại. int a = 7;if(!(a == 7)){ // (a==7) =&gt; true gặp thằng ! lại bị chuyển thành false. =&gt; vào vế else  System. out. println( Đáng nhẽ ra nên vào đây );}else{  System. out. println( But nope, nó lại vào đây );}#2 Hàm (Function): Giới thiệu: Cùng nhìn vào ví dụ này nhé các bạn: int a = 5 + 6;System. out. println( In a ra màn hình:   + a);a = 1 + 6;System. out. println( In a ra màn hình:   + a);a = 2 + 6;System. out. println( In a ra màn hình:   + a);Đây là một chương trình tính tổng 2 số rồi in ra màn hình. Tất nhiên hiện tại chúng ta chưa học cách nhập xuất trong Java nên sẽ fix cứng trong code để làm ví dụ. Các bạn thấy là chúng ta phải viết việc a = xx + yy 3 lần và viết System. out. println( In a ra màn hình:   + a); 3 lần. Việc này thực sự đã lặp lại các bất cập trong việc viết code khi phải thực hiện một chức năng lặp đi lặp lại nhiều lần. Để giảm thiểu việc viết lại code nhiều lần chúng ta có khái niệm `Hàm (Function); Các bạn nhìn ví dụ, mình sẽ giải thích: public class Calculation {  public static void main(String[] args){    f(5,6);    f(2,3);    f(1,10);  }  public static void f(int x, int y){    int a = x + y;    System. out. println( In a ra màn hình:   + a);  }}// Kết quả khi chạy:// In a ra màn hình: 11// In a ra màn hình: 5// In a ra màn hình: 11Từ ví dụ, chúng ta sẽ liên tưởng tới khái niệm toàn học hồi cáp 2, hàm f(x). Là cách các nhà toán học ký hiệu cho một hàm số nào đó, sau chỉ cần thay x vào là được, còn về cơ bản nó vẫn là một hàm số và thay đổi tham số đầu vào. Nguyên tắc sử dụng hàm để tiết kiệm thời gian viết cũng như đóng gói chức năng là như vậy. Cách khai báo: Cách khai báo một phương thức như sau: [kiểu_truy_cập] [kiểu_trả_về] [tên_phương_thức] ([danh_sách_tham_số]){} ví dụ: public static void f(int x, int y){ //Code của bạn }public static void main(String[] args){}Và khai báo ở ngoài hàm main(). Tới đây, bạn hiểu main() cũng là một hàm (function). Tuy nhiên nó đặc biệt vì cú pháp của nó là cố định và được Java tìm tới để đọc đầu tiên. 1 - [kiểu_truy_cập]: Trong ví dụ trên [kiểu_truy_cập] chính là vế public static. Nó định nghĩa phạm vi hàm được sử dụng. chúng ta sẽ tìm hiểu ở các bài sau nhé các bạn, bây giờ bạn hãy mặc định sử dụng public static ở trước mỗi hàm khai báo để có thể sử dụng được nhé. Ở bài này, chúng ta tạm hiểu với nhau: public static là  truy cập ở bất cứ đâu  tức có thể gọi hàm này ở bất kì chỗ nào. 2 - [kiểu_trả_về]: Tương đương với phần void ở ví dụ trên, kiểu trả về là giá trị chúng ta nhận được sau khi gọi hàm. Bạn hãy nhớ lại, khi truyền x vào f(x) chúng ta sẽ nhận lại là y. Thì hàm cũng vậy, chúng ta có thể trả lại một giá trị gì đó. ví dụ: // [kiểu trả về]: intpublic static int tong(int x, int y){  int t = x + y; // Tính tổng 2 só x, y  return t; // trả số đó ra sử dụng câu lệnh `return {biến}`}public static void main(String[] args){  int t = tong(5,6); // Lấy giá trị trả ra, gán nó vào t;}Tôi định nghĩa một hàm tính tổng tong(x,y) nhận vào 2 số nguyên, và yêu cầu nó trả ra một số int. Các kiểu trả về:  primitive: int, boolean, char, … Object: String, (còn rất nhiều, sẽ học ở bài tiếp theo) void: Không trả về gì cảỞ ví dụ đầu tiên mình đã sử dụng void để định nghĩa hàm. public static void f(int x, int y){  int a = x + y;  System. out. println( In a ra màn hình:   + a);}Điều này nói là hàm của chúng ta thực hiện một hoạt động khép kín, và không có nhu cầu trả ra ngoài cái gì cả. Mình chỉ tính tổng rồi in luôn ra màn hình thôi, không cần đưa gì ra ngoài cả. 3 - [danh_sách_tham_số] Tham số đầu vào, là những thứ chúng ta đưa vào hàm, định nghĩa tham số đầu vào bao gồm [kiểu_dữ_liệu] [tên_biến]. Chúng ta có truyền nhiều tham số vào hàm bằng cách đặt dầu phẩy , giữa mỗi tham số. public static int f(int x, int y, int z, . . . ){  // code}Ở đây lưu ý phần [tên_biến] bạn có thể đặt tên bất kỳ. chẳng hạn: // Hàm nhận vào 2 biến `x`, `y` và trả ra kết quả `boolean` xem nó có bằng nhau hay khôngpublic static boolean bangnhau(int x, int y){  return x == y;}public static void main(String[] args){  int a = 5; // tên biến là `a`  int b = 6; // tên biến là `b`  boolean ketqua = bangnhau(a,b); // đưa `a` , `b` vào hàm.   // bản chất khi gọi hàm `bangnhau`:  // int x = a;  // int y = b;  // return x == y;  //  System. out. println( Kết quả:   + ketqua);}Bạn định nghĩa tham số đầu vào là x và y thì nó chỉ hiểu trong ở hàm đó thôi, và những giá trị truyền vào sẽ gán vào các biến x và y. Thực hành: Sau đây chúng ta sẽ ứng dụng những kiến thức đã học để làm một chương trình đơn giản: Cho 3 số nguyên a, b, c tượng trưng cho 3 cạnh AB, AC, BC của tam giác ABC. Kiểm tra ABC có phải tam giác không? nếu có, là tam giác gì? Nhắc lại: Chúng ta chưa học nhập xuất dữ lịệu trong Java nên chúng ta sẽ gán giá trị ngay trong code và chạy test. public class Calculation {  public static void main(String[] args) {    int a = 5, b = 5, c = 5; // tường hợp tác giác đều    // Các bạn tự thay số vào để kiểm tra nhé.     if (laTamgiac(a,b,c)){      System. out. println( Là tam giác! );      if(laTamgiacDeu(a,b,c)){        System. out. println( Và còn đều nữa! );        // Là tam giác đều thì không cần kiếm tra điều kiện còn lại nữa.       }else {        if (laTamgiacVuong(a, b, c)) {          System. out. println( Và còn vuông nữa! );          // Không thể xảy ra vuông cân. Vì chúng ta đầu vào chỉ là số nguyên.           // Còn muốn đầy đủ, bạn phải kiểm tra trường hợp vừa vuông vừa cân nữa.         }        if (laTamgiacCan(a, b, c)) {          System. out. println( Và còn cân nữa! );        }      }    }else{      System. out. println( Không phải là tam giác! );    }  }  public static boolean laTamgiac(int a, int b, int c) {    if ((a + b) &gt; c &amp;&amp; (a + c) &gt; b &amp;&amp; (b + c) &gt; a) {      // Tam giacs: tổng 2 cạnh phải lớn hơn cạnh còn lại      return true;    } else {      return false;    }  }  public static boolean laTamgiacVuong(int a, int b, int c){    if ((a*a + b*b) == c*c || (a*a + c*c) == b*b || (b*b + c*c) == a*a) {      // Là tam giác vuông nếu có 1 trong các đièu kiện thoả mãn pythagore.       return true;    } else {      return false;    }  }  public static boolean laTamgiacCan(int a, int b, int c){    if (a == b || b == c || c == a) {      return true;    }else{      return false;    }  }  public static boolean laTamgiacDeu(int a, int b, int c){    if (a == b &amp;&amp; b == c) {      return true;    }else{      return false;    }  }}Học tới bài 3 là các bạn đã có thể viết các ứng dụng rất ra gì rồi đây hố hố 😂 Tuy nhiên các bạn sẽ thấy còn khá nhiều bất cập đó là các biến a,b,c chúng ta đang để cố định trong code thay vì tự nhập từ bàn phím. Yên tâm là ở ngay bài sau chúng ta sẽ học phần này và bổ sung vào bài tập này nhé. Chúc các bạn học tốt và chớ quên chia sẻ cho bạn bè :3 "
    }, {
    "id": 44,
    "url": "https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/",
    "title": "「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java",
    "body": "2019/03/20 - Hế luuuuu everyone, lại là mình Loda đây, chào mừng các bạn quay trở lại với series Thành thạo Java Basic trong 2 tuần. . Trong bài ngày hôm nay, chúng ta sẽ học về Biến, Kiểu dữ liệu và một số các Toán tử trong Java nhé các bạn. Bài này sẽ khá nhiều ví dụ và kiến thức nên chúng ta vào bài luôn hah. Biến &amp; Kiểu dữ liệu: Chúng ta sẽ chạy một ví dụ trước rồi đi vào chi tiết nhé. Các bạn tạo một project mới, đặt tên là Bài 2 hay gì cũng được, tuỳ bạn chọn nhé. Và tạo cho mình một file là Calculation. java như hình.  Sau đó các bạn viết code như này và chạy thử: public class Calculation{  public static void main(String[] args){    // khai bao so nguyen    int a = 5;    int b = 10;    int x = 10 + 5;    System. out. println(x);  }}Các bạn chạy chương trình này (click chuột phải vào file Calculation &gt; Run Main()). sẽ thấy hiện kết quả là c = 15; Nhìn code thì rất dễ hiểu phải không, tuy nhiên chúng ta cùng lí giải chi tiết để hiểu hơn về Biến và Kiểu dữ liệu trong Java. Thứ nhất là cái // khai bao so nguyen, cái này gọi là Comment, tức các bạn viết gì sau 2 cái dấu // thì nó sẽ không ảnh hưởng tới code của chương trình, nó chỉ mang ý nghĩa chú thích thôi. Thứ hai là cái này: int a = 5;Nói về Biến (Variable) các bạn có liên tưởng tới liên tưởng tới biến x trong đồ thị hàm số ax + b = 0 không 😂 Thì chính là nó đấy.  Biến sẽ giúp chúng ta lưu trữ và quản lý các giá trị trong chương trình. Trong Java, Biến cũng là đại diện cho một đối tượng và đối tượng này phải được xác định là thuộc Kiểu dữ liệu nào. Sẽ giống với phương trình x kia, nhưng đề bài phải ghi rõ x là số nguyên, số thực hay số phức để người làm bài người ta còn biết. Có các kiểu dữ liệu nguyên thuỷ (primitive) như sau:  boolean: là kiểu logic, chỉ có 2 giá trị true hoặc false char: kiểu ký tự, chỉ chứa đc được một ký tự, được định nghĩa trong dấu ngoặc đơn ' int : số nguyên (1,2,3, . . ) long: số nguyên, lớn hơn int. (sẽ giải thích ở dưới) float: số thực (1. 5, 2. 5, . . ).  double: số thực, lớn hơn float. Ngoài ra còn 2 kiểu dữ liệu nhỏ hơn int là byte và short. Thì mình sẽ nói sau hah. Còn trước mắt tập trung vào các nhóm chính kia đã. Tiếp đến là kiểu dữ liệu cao cấp hơn gọi là Object mà đặc trưng nhất là String.  String: Một chuỗi các ký tự, được định nghĩa trong dấu ngoặc kép   . vd String a =  Hellooo world~~~  (Nhớ tới ví dụ ở Bài #1 hem các bạn)Mọi loại dữ liệu đều có một cái gọi là Giá trị mặc định, khi các bạn không cung cấp cho nó giá trị, nó sẽ tự có 1 giá trị mặc định.                     Kiểu dữ liệu        Giá trị mặc định        Kích thước                    boolean        false        1 bit                    char        '\u0000'        2 byte                    byte        0        1 byte                    short        0        2 byte                    int        0        4 byte                    long        0L        8 byte                    float        0. 0f        4 byte                    double        0. 0d        8 byte                    String        null                    Ở đây bạn sẽ thấy có chữ L f d sau số 0. Đó là những ký tự đánh dấu cho Java phân biệt là số 0L là số 0 nhưng dạng long, f là dạng float, d là double. Cách khai báo: Để khai báo biến, bắt buộc trước đó bạn phải chỉ cho nó kiểu dữ liệu mà nó sẽ nhận, ngoài ra có thể có giá trị hoặc không.  Cách 1: [kiểu_dữ_liệu][tên_biến]; Cách 2: [kiểu_dữ_liệu][tên_biến] = [giá_trị];int a, b, c; // Khai báo 3 biến có kiểu dữ liệu intfloat b = 4. 5f, c = 4f; // Khai báo 2 biến có kiểu dữ liệu float với giá trị ban đầu. ở đây biến `c` sẽ được hiểu là c = 4. 0double c = 4444. 3;char t = 'c';String e =  Hello ;Cách đặt tên: Trong Java, tuy không bắt buộc, nhưng chúng ta luôn thống nhất với nhau cách đặt tên biến theo một nguyên tắc, để đảm bảo khi đọc code sẽ có tính nhất quán và chuẩn chỉnh.  Tên biến phải tuân theo quy tắc lạc đà (Camel Case): đó là chữ cái đầu tiên của từ đầu tiên phải viết thường và chữ cái đầu tiên của các từ tiếp theo phải viết hoa, ví dụ: listStudent, minScore. Chi tiết các bạn xem ở đây nhé, nói ra khá dài, nhưng nắm được cái ý ở trên của mình là cũng khá ổn r. Phạm vi sử dụng: Một khi bạn đã khai báo biến, thì bạn có thể sử dụng nó trong những Phạm vi mà nó khả dụng. ?? 😀?? Cùng nhìn ví dụ ở dưới nhé. Ví dụ: public static void main(String[] args){  // khai bao so nguyen `a`  int a;  // Gán giá trị cho a, bạn sử dụng toán tử `=`  // Sử dụng biến a bình thường  a = 124214;  // lấy a và cộng thêm 1,, rồi gán ngược lại giá trị đó vào a :D  // Sử dụng biến a bình thường  a = a + 1;}// Gán lại giá trị cho a = 100 - 10;// Chương trình lỗia = 100 - 10;Phạm vi (Scope) là đây các bạn ạ, chính là 2 cái dấu {}, khi bạn khai báo một biến a trong 2 cái dấu { } thì bạn chỉ có thể sử dụng ở trong nó thôi, ra ngoài nó sẽ không hiểu a là thằng nào và từ đâu chui ra.  Biến không thể sử dụng ngoài, nhưng nó có thể được sử dụng ở bên trong những scope mà nó chứa hoặc cùng cấp với nó. public class Calculation{  // Khai báo a ở ngoài main, cái `public static` là cần thiết nhé, còn chi tiết thì chúng ta sẽ học ở các bài sau.   public static int a = 5;  public static void main(String[] args){    // thay đổi a, ở trong, vẫn okie.     a = 10;    // Biến a có thể sử dụng trong các `scope` con của nó    // Làm gì biến a ở đây cũng được, biến đổi nó.     // gán giá trị biến a vào b;    int b = a;    System. out. println(b);  }}Toán tử: Khi đã xác định các Biến trong chương trình, bạn có thể sử dụng toán tử để thay đổi các giá trị. Các toán tử thì khá đơn giản, giống môn toán bình thường thôi. Với các kiểu nguyên thuỷ (primitive) ta có: public class Calculation{  public static void main(String[] args){   int a;   int b = 5;   int c = a + b; // c = 0 + 5 cộng   int d = a - b; // d = 0 - 5 trừ   int f = a * 5; // f = 0 x 5 nhân   int g = a / 5; // g = 0 : 5; chia  }}Còn với String thì bạn có thể sử dụng + để ghép 2 chuỗi mà thôi. Còn các toàn tử còn lại không được sử dụng với String public class Calculation{  public static void main(String[] args){   String a =  Hello    String b =  World    // Mình đã nối 3 xâu là  Hello  +     (Khoảng trắng) +  World  lại với nhau   System. out. println(a +     + b);   String c = a + 5; // String cộng với một số nguyên?   System. out. println(c); // Kết quả sẽ là:  Hello 5  :V   // Bạn sẽ hiểu là khi cộng String với một số, số đó sẽ bị chuyển thành String và nối vào sau.   }}Ở trên có một ví dụ về việc cộng một String với int. Rất kì lạ phải không, 2 kiểu dữ liệu khác nhau khi tính toán với nhau thì sẽ được Java xử lý bằng cách Ép kiểu. Ép kiểu dữ liệu: Nhìn vào ví dụ sau, bạn sẽ rõ. public class Calculation{  public static void main(String[] args){   int a = 2;   float b = 3. 5f; // dùng chữ f để nó hiểu đây là 3,5 float chứ k phải 3,5 double   float c = a + b; // c = 5. 5   int d = a + b; // báo lỗi. Vì sao?   // vì java đang hiểu 2 + 3. 5 nó sẽ ép thành 5. 5 là float. Bây giờ gán nó vào số nguyên thì sẽ như này int = float?   // Để gán được bạn cần sử dụng ép kiểu   int d = (int) a + b; // d = 5   // a + b = 5. 5 =&gt; ép thành (int) =&gt; 5 (lấy phần nguyên thôi)   char character = '5';   int number = (int) character; // number = 53. Why?   // Vì ép `char` thành `int` thì nó sẽ không chuyển chữ thành số, mà nó sẽ kiếm tra '5' là ký tự ASCII thứ bao nhiêu trong máy tính, và trả lại số thứ tự đó.    float = (float) 5; // =&gt; 5. 0  }}Tới đây là các bạn đã có thể sử dụng được Biến trong Java rồi đó, có thể sử dụng làm bài tập được rồi kakakakaka :D, còn phần dưới đây mình sẽ nói thêm về bản chất của Biến và giới hạn giá trị của nó. Bản chất của biến (Nói thêm): Khi các bạn khai báo một biến int trong chương trình của mình và sử dụng lung tung khắp mọi nơi, thì bạn có biết cái biến int ý ở đâu lòi ra không :)) Về bản chất, Biến sẽ là một vùng nhớ trong thiết bị vật lý mà dễ nhất là để trong ram. và khi bạn cho nó một giá trị, nó sẽ lưu trữ số đó vào ram, và cần thì lấy lên.  Vậy để ram biết bạn muốn lưu cái gì thì bạn phải khai báo cho nó. Ví dụ bạn bảo tôi cần một số nguyên int. Thì máy tính hiểu là mình cần lưu trữ một số nguyên bình thường, không quá lớn, nó sẽ cho bạn 4 byte trong Ram thích lưu gì thì lưu. nhưng không được vượt quá 4 byte.  4 byte = 32 bit, bỏ đi 1 bit đầu tiên để đánh dấu là số âm hay dương, thì còn 31 bit =&gt; số lớn nhất mà biến int lưu trữ được là 2^31 - 1 = 2147483647 Từ đây, bạn sẽ hiểu vì sao có số long, vì nhu cầu lưu số lớn hơn thì long được cấp tận 8 byte. Còn trường hợp đặc biệt như String thì tuỳ giá trị của nó có bao nhiêu ký tự, mà Ram sẽ cấp tương ứng bấy nhiêu byte Lời kết: hết rồi kaka 😄Ở các bài sau mình sẽ vừa đi vừa nói lại những phần còn thiếu trong Biến này nên các bạn chớ lo nhé. Chúc các bạn học tập tốt. Nhớ like và chia sẻ cho bạn bè nhé ahehe/ "
    }, {
    "id": 45,
    "url": "https://loda.me/Java-basic-1-Gioi-thieu-Java-Cai-dat-moi-truong-va-Hellooo-world/",
    "title": "「Java basic #1」Giới thiệu Java, Cài đặt môi trường và Hellooo world~",
    "body": "2019/03/19 - Xin chào tất cả các bạn, chào mừng các bạn đến với bài đầu tiên trong khóa học Thành thạo Java Basic trong 2 tuần. . Mình là loda sẽ đồng hành cùng các bạn trên công đường làm chủ ngôn ngữ jav này 🤗 Bài đầu tiên trong series này là giới thiệu cực kì ngắn gọn với các bạn Java là gì, đủ ý dễ hiểu, tập trung vào việc cài đặt môi trường, cài đặt công cụ lập trình. Okayyy vào bài. Java: Bắt đầu từ một câu chuyện:  Tại một vương quốc nọ năm 19xx (TCN), có một anh lập trình viên, khi đang viết phần mềm cho Windows 9x, thì sếp yêu cầu anh viết thêm cho cả Linux, OpenVMS, FreeBSD, IBM, v. v. . Chàng thanh niên không nói gì, anh chững lại đôi chút, lấy điếu thuốc rít một hơi, mắt anh nhìn xa xăm, đôi mắt anh lúc đó hồn nhiên tới lạ, tôi nghĩ nó là đôi mắt biết nói, nó nói: “f**k 🙂” Đấy, đấy là câu chuyện của mình, còn lịch sử Java các bạn đọc ở đây nhé 😆 Mình tóm tắt giúp bạn là Java được ra đời với mục tiêu là  viết một lần, chạy mọi nơi  ( write once, run anywhere ). Vì bản thân các OS là khác nhau, các lập trình viên không muốn với mỗi một OS lại phải code lại từ đầu. Nên Java ra đời. Năm 1995. Lấy người anh C/C++ làm nền tảng học tập, Java tiếp thu, cải thiện hơn và áp dụng mô hình hướng đối tượng chuẩn mực hơn. Từ đó trở thành ngôn ngữ mạnh mẽ nhất thời bấy giờ. Đấy ngắn gọn thế thôi, để não bộ tiếp thu tiếp. Cài đặt môi trường: Môi trường là seo? hổng hiểu 😕 Các bạn cứ tưởng tượng bạn đang xem một bộ Film vậy, trên thế giới có film Mỹ, Tàu, Jav, v. v. . mỗi film một thứ tiếng, nà ní, nhưng sao bạn vẫn xem và hiểu? Vì nó có Phụ đề. Java hoạt động như vậy, nó chỉ nói 1 ngôn ngữ duy nhất thôi, tuy nhiên nó có một thằng anh bá đạo, tên ông ý nôm na là môi trường ảo hay tên chuẩn là Java virtual machine (JVM). Nhiệm vụ của JVM là nó phụ đề (thuyết minh) cho từng loại OS khác nhau rằng thằng Java đang làm gì, nói gì, làm gì.  Vì chúng ta là Developer nên chúng ta không chỉ muốn cài môi trường mà còn muốn code trên nó nữa. nên chúng ta sẽ cài gói JDK (Java Development Kit) luôn. Nó chứa các công cụ giúp lập trình Java ngoài ra trong quá trình cài, nó sẽ hỏi ta muốn cài môi trường luôn JRE (Java Runtime Enviroment, thằng này chứa cả thằng JVM ở trên), tiện lợi. Nếu các bạn xài Windows hoặc MacOS thì click vào đây để download: https://www. oracle. com/technetwork/java/javase/downloads/jdk8-downloads-2133151. html, Nhớ chọn Accept lincense agreement trước khi download. Khi download xong, bạn mở file và làm theo hướng dẫn nhé. Đây là trang “chính chủ” nên bạn không cần lo về virus hay gì cả, cứ chọn next và accept mọi gợi ý là tốt nhất, tránh phải làm thêm các thao tác phụ.  Còn Unix thì các bạn nên sử dụng apt-get tự động setup cho dễ, nếu đã xài Unix thì vụ này rành rồi hah, mình k hướng dẫn gõ lệnh đâu hê hê 😄: sudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installerCài đặt Intellij IDEA và kích hoạt bản quyền. : Intellij IDEA chỉ làm một “công cụ” lập trình, giúp các bạn viết code dễ dàng hơn, giúp cuộc sống của bạn bớt lo lắng về những vấn đề khác mà chỉ cần tập trung vào viết code thôi.  Download tại: https://www. jetbrains. com/idea/download/ Hiện Intellij có 2 phiền bản, Ultimate là mất phí nhưng bá đạo thôi rồi, còn Community là miễn phí (vẫn tốt nhé). Bình thường không có điều kiện thì các bạn xài Community được rồi. TUY NHIÊN…😗 MÌNH CÓ KEY BẢN QUYỀN Ở ĐÂY loda. me/jetbrains. nên các bạn cứ down Ultimate về mà xài nhé… Nhớ làm theo hướng dẫn trong link. Cài đặt thì cũng giống với JDK là chọn next và accept mọi mục để hưởng dịch vụ tốt nhất. Hellooo world~: Được roài, sau một loạt các bước cài đặt cần thiết, thì bạn bây giờ đã sẵn sàng để bắt đầu Lập trình Java. Mở Intellij lên nào, chọn Create new project Nhập tên cho Project của bạn, chọn thư mục lưu trữ cho nó, rồi nhấn OK. Bạn tạo xong chưa? xong rồi thì cùng nhìn vào cấu trúc của project nhé. Bạn sẽ thấy có 3 thư mục:    . idea: Thằng này là thư mục do Intellij tự tạo ra để chứa các file config của phần mềm này, bạn sẽ k cần quan tâm đến, để nó tự nhiên đê :D     src: Đây là thư mục chính bạn sẽ làm việc, tất cả code bạn để trong này     {project-name}. iml: File này cũng do Intellj tạo ra và quản lý module, bạn không cần quan tâm nó.  Okay,, hiểu kiến trúc 1 project Java cơ bản rồi,, bắt tay vào code luôn thoai. :3 Bạn vào thư mục src tạo 1 file cho mình tên là Main. java nhé. Trong code bạn sẽ viết như này, mình sẽ giải thích sau khi bạn chạy được chương trình. public class Main {  public static void main(String[] args) {    System. out. println( Hellooo World~~~, I'm loda );  }}Bạn click chuột phải vào file trên màn hình, chọn Run Main. main() để chạy chương trình nhé. Note:  Nếu là lần đầu, Bạn sẽ phải kiểm tra setting một chút, cho chắc, để nó biết Intellij đã biết thư mục JDK mà bạn cài ở bước 2 chưa.   Bạn vào File &gt; Project Structure. . . &gt; Project SDKNếu thấy như hình, nó nhận 1. 8 là okie, k cần lo lắng gì nữa. Nếu chưa có, bạn chọn mũi tên xem nó có sẵn chưa, nếu chưa, chọn New và chỉ dẫn nó tới thư mục JDK bạn đã cài ở bước 2 (C:/Program File/Java/jdk 1. 8 cho Windows hoặc /Library/Java/JavaVirtualMachines/jdk1. 8. 0_201. jdk/Contents/Home cho MacOs). Okie bạn đã thấy dòng chữ Hellooo World~~~, I'm loda in ra màn hình phải không. Thế là bạn đã chạy chương trình Java đầu tiên thành công rồi đấy hú hú :333 Góc Giải thích. Ví dụ này bạn sẽ dễ nhận thấy các điều cơ bản sau:  Cơ bản thì file code sẽ nằm trong thư mục src File code sẽ có tên kết thúc bằng . java Tên file là A thì trong file đó sẽ mặc định là public class AThế cái public class A là cái gì? Cái này mình sẽ giải thich ở các bài sau bạn nhé. tạm thời bạn hãy cứ tạo file A. java và mặc định làm việc bên trong đoạn public class A. (cứ hiểu nó như là 1 thằng đánh dấu, rằng tao là A, không phải B cũng được kakaka). Còn chương trình chính của bạn chỉ có thể này thôi: public static void main(String[] args) {  System. out. println( Hellooo World~~~, I'm loda );}   public static void main(String[] args): (Gọi tắt là psvm nhé) Cái thằng này sẽ là nơi Java tìm tới đầu tiên, và đọc toàn bộ các đoạn code trong cái thằng tên là psvm này. Dù nó ở bất cứ đâu, nó sẽ được tìm tới.     2 cái dấu { }: Đánh dấu đoạn bắt đầu và kết thúc của cái public static void main(String[] args) kia.  Vậy là thằng Java sẽ đi lùng tìm, xem cái thằng psvm xem nó ở đâu. Rồi đọc hết tất cả những thứ nằm trong cái 2 dấu { } của thằng này. Vậy trong ví dụ của chúng ta, nó sẽ đọc cái gì? bạn thấy đấy, chi có 1 dòng duy nhất thôi :v System. out. println( Hellooo World~~~, I'm loda );Nhìn dòng này chúng ta sẽ biết:  Các dòng code của Java đều kết thúc bằng dấu ; (Ngoại trừ cái thằng { } nhé) System. out. println(): là câu lệnh in ra màn hình.   Hellooo World~~~, I'm loda : là thứ sẽ được in ra màn hình, dấu ngoặc kép   cho Java biết đây là một đoạn text, chứu không phải một con số, một con chim, hay một con mèo gì cả. Kết: Okieeeee lahhh, Thế là xong bài đầu tiên,, chúc mừng các bạn đã bước 1 chân vào thế giới Java đầy huyền bí :3 Có gì thắc mắc bạn cứ tự nhiên comment ở bên dưới nhé! Chớ quên like và share cho bạn bè,, ahihi! "
    }, {
    "id": 46,
    "url": "https://loda.me/Java-basic-0-Gioi-thieu-Series-Java-can-ban-thanh-thao-java-trong-2-tuan",
    "title": "「Java basic #0」Giới thiệu Series Java căn bản.",
    "body": "2019/03/19 - Xin chào tất cả các bạn, mình là loda. Hôm nay mình sẽ giới thiệu tới các bạn khóa học Java căn bản trong 2 tuần. Mục tiêu là giúp các bạn, dù xuất phát điểm như nào cũng có thể nắm được ngôn ngữ này trong 2 tuần 😗 (rìa lý men) Mặc dù mục đích ban đầu blog của mình hướng tới là chia sẻ các kiến thức nâng cao về Java, Spring, v. v. . Vì bản thân mình nghĩ các kiến thức cơ bản thì có quá nhiều nguồn để học rồi 😳 ấy vậy mà không như thế các bạn ạ 😳 . Chính vì nhiều nguồn quá rồi, nó lại khiến các bạn bối rối giữa việc chọn nguồn tài liệu và giáo trình, dẫn tới học chắp và, không hiệu quả, và thường mất thời gian mới hiểu được bản chất ngôn ngữ này, vì theo mình khảo sát thì các bài viết không đầu tư đủ nội dung, thường là “mì ăn liền”. Thứ 2, cũng là mục đích chính, có bạn muốn mình giúp đỡ nên mình quyết định viết series này. :v ha ha . . ha  Series: Java Basic Số bài: 14 ~ 18Mục tiêu đạt được sau khóa học:  Hiểu và sử dụng được ngôn ngữ Java.  Nắm bắt được các khái niệm cơ bản về OOP.  Biết các lib phổ biến của Java.  Sử dụng Java giải quyết bài toán thực tế. Nội dung bài học mình sẽ cố gắng cô đọng trong số lượng ít bài học nhất có thể 🤔 zì sao ? Mình không biết các bạn lực học ra sao, và xuất phát điểm như nào, nhưng mình nghĩ việc chia quá nhỏ bài học ra đôi khi lại phản tác dụng, nó cứ lắt nhắt mà không cô đọng được mỗi lần học. Mình nghĩ nên tập trung kiến thức liên quan thành một và học 1 mạch, nó sẽ có cái flow, cái đà học, thì mới vào được 😗 Chứ cứ mỗi bài các bạn chỉ mất 5 - 10’ lướt qua, thì các bạn sẽ nghĩ là “à, xong 1 bài, đơn rản, thưởng mình 10’ facebook thư giãn”. Tới ngày hôm sau bạn sẽ lại phải tìm lại cái bài ý để đọc :v mất thời gian x 2 and ghi nhớ x 0. Giới thiệu sơ qua vậy ha, yên tâm là mình sẽ cố gắng viết cô đọng, nhưng vẫn truyền tải đủ ý và giúp mọi hiểu bản chất ha :3 Giờ thì đi vào bài học nhé các bạn:  「Java basic #1」Giới thiệu Java, Cài đặt môi trường và Hellooo world~ 「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java 「Java basic #3」Hàm và câu lệnh điều kiện 「Java basic #4」Nhập xuất dữ liệu trong Java Ongoging. . "
    }, {
    "id": 47,
    "url": "https://loda.me/Nang-cao-Huong-dan-su-dung-Criteria-API-trong-Hibernate/",
    "title": "「Hibernate #1」Hướng dẫn sử dụng Criteria API trong Hibernate",
    "body": "2019/03/17 - JPA Criteria API cho phép ta tạo ra các câu truy vấn bằng Java Object thay vì việc khai báo trực tiếp trong String (JPQL) như thế này: SELECT o FROM Office oTương đương với câu lệnh trên nhưng xây dựng bằng Criteria API thì sẽ như này: CriteriaBuilder cb = em. getCriteriaBuilder();CriteriaQuery&lt;Office&gt; q = cb. createQuery(Office. class);Root&lt;Office&gt; c = q. from(Office. class);q. select(c);Nhìn có vẻ dài dòng và khó hiểu phải không &gt;”&lt; Yea, thì đúng là như thế đấy ==! Nếu nó dài dòng như vậy, tại sao người ta lại tạo ra và sử dụng nó thay cho câu lệnh JPQL bình thường? Các bạn đọc phần tiếp theo sẽ rõ nha. JPQL vs Criteria API: JPQL có thể làm đầy đủ chức năng chúng ta cần chỉ với 1 câu lệnh, tuy nhiên, chính vì điều đó, chúng ta thường khó tùy biến hay sử dụng lại nó, thậm chí khó kiểm soát lỗi của nó hơn. Với một câu lệnh phức tạp, chúng ta không biết được nó có lỗi hay không cho tới khi chạy chương trình hay debug (Mà chương trình đã chạy được rồi thì vẫn có lỗi tiềm ẩn :v chời đậu). Criteria API thì ngược lại, nó cho phép chúng ta xây dựng câu lệnh một cách Dynamic, rất linh động, và không bị hardcode trong một String và có thể tái sử dụng lại được. Đặc biệt, vì là Java Object, nên chúng ta sẽ biết một câu lệnh bị lỗi, không đúng quy tắc ngay khi biên dịch chương trình rồi. Túm váy lại, với một lệnh đơn giản như ví dụ đầu bài, thì các bạn nên xài JPQL, còn với những câu lệnh phức hợp, thay đổi theo context của chương trình thì nên sử dụng Criteria. How to use. : Quay trở lại với ví dụ ban đầu nhé: CriteriaBuilder builder = em. getCriteriaBuilder();CriteriaQuery&lt;Office&gt; query = builder. createQuery(Office. class);Root&lt;Office&gt; root = query. from(Office. class);query. select(root);Chúng ta cùng tìm hiểu từng dòng lệnh:    CriteriaBuilder: Để xây dựng một câu query, các bạn sẽ cần tới interface CriteriaBuilder, mục đích của nó là giúp tạo ra đối tượng chứa câu lệnh truy vấn CriteriaQuery và cung cấp cơ số các phép biến đổi, phép logic, điều kiện cho câu lệnh (and, or, not, avg, greater than,v. v…)   CriteriaQuery: Đối tượng chính của chúng ta đây, nó được tạo ra bởi builder. createQuery(Office. class). Mục đích là khai báo đối tượng bạn muốn lấy ra sau khi thực hiện query. Nó tương đương với đoạn ngoặc đơn ở dưới đây:  SELECT `o` FROM Office o    Root: root là khai báo đối tượng bạn sẽ sử dụng trong query, tương đương với đối tượng sau mệnh đề FROM  SELECT o FROM `Office o`   Cuối cùng, để hoàn thiện câu lệnh SELECT chỉ đơn giản là lấy đối tượng CriteriaQuery đã khai báo là sử dụng function select. Đối tượng truyền vào chính là cái root (hay cái đối tượng của FROM) kia. query. select(root);Trông vậy chứ cũng dễ dễ rồi đấy nhỉ :))) Okie, có điều này không biết đã bạn nào để ý chưa 😅 chúng ta mới tạo ra câu lệnh, chứ chưa hề gọi nó xuống Database 😅 Để sử dụng câu lệnh đã tạo, các bạn làm giống với JPQL đó là sử dụng đối tượng EntityManager TypedQuery&lt;Office&gt; query = em. createQuery(query);List&lt;Office&gt; results = query. getResultList();Oh right, thế là implement xong ví dụ đơn giản đâu tiên, không cóa gì khó khăn 🤔 (chém). Bây giờ thử advanced lên tý nhỉ: Bây giờ mình muốn lấy tất cả Office ở thành phố hanoi thì sẽ làm như nào? SELECT o FROM Office o WHERE o. city = 'hanoi'Lúc này query của chúng ta sẽ như thế này: query. select(root). where(builder. equal(root. get( city ),  hanoi ));Các bạn để ý đoạn này nhé. Mình sử builder để lấy hàm equal (phép toán logic, như mình đề cập ở trên, chuẩn chưa nào). Tiếp tới là cái root. get( city ), root chính là đối tượng chúng ta đã khai báo, bây giờ chúng ta sẽ lấy trường city của nó và kiểm tra nó với hanoi. Có thể nói Criteria API đã hiện thực hóa rất thành công câu lệnh JPQL (hay HQL) thành những api java cực kì dễ dọc, dễ hiểu và dễ sử dụng. Khi đã hiểu được câu lệnh gốc, bạn có thể dễ dàng chuyển nó thành Criteria và ngược lại. Trong bài viết tới ở chương Spring, mình sẽ hướng dẫn các bạn sử dụng tới Specifications kết hợp Criteria API để tạo ra một vụ nổ khi giao tiếp với db bằng Java (vãi cả chém 😂) Chúc các bạn sử dụng thành công Criteria API và đừng quên like or chia sẻ bài viết cho bạn bè hihi, cảm ơn các bạn đã theo dõi! "
    }, {
    "id": 48,
    "url": "https://loda.me/huong-dan-chi-tiet-tu-xay-dung-mot-mang-neural-(no-ron)-voi-python/",
    "title": "Hướng dẫn chi tiết tự xây dựng một mạng neural với Python",
    "body": "2019/03/07 - Google đã xây dựng tensorflow như một công cụ để xây dựng các mô hình deep learning một các đơn giản và tối ưu chỉ với vài dòng code. Tuy nhiên, nếu chỉ sử dụng các API này thì thật khó để biết được các cách thức hoạt động đằng sau của từng thành phần trong mô hình. Bài viết này sẽ hướng dẫn các bạn cách xây dựng mạng neural một cách chi tiết qua từng dòng lệnh, từ đó có một cái nhìn rõ ràng hơn về cách hoạt động của chúng. Đây là bài viết nói về cả quá trình và các bước thực hiện trong 1 mạng neural, nên sẽ không đi sau chi tiết từng phần nhưng vẫn cung cấp cho bạn kiến thức để hiểu được vai trò của nó trong cả kiến trúc. Mạng neural là gì?: Mạng neural có thể coi là một phương thức để miêu tả cách hoạt động trong bộ não của con người. Nói một cách đơn giản hơn, mạng neural là một hàm nhận một đầu vào x, xử lý nó và đưa ra một đầu ra y tương ứng. Mạng neural gồm những thành phần sau:  Một lớp biểu diễn đầu vào x Một số lượng các lớp ẩn - hidden layers Một lớp biểu diễn đầu ra y Một bộ các chỉ số weights(W) và bias(b) giữa các lớp Một hàm kích hoạt - activation function giữa các lớpHình dưới đây miêu tả một kiến trúc mạng neural gồm 2 lớp (lớp đầu vào x thường không được tính vào số lượng lớp của mạng)   Giờ thì chúng ta sẽ bắt đầu xây dựng kiến trúc trên với Python. Đầu tiên là khởi tạo class NeuralNetwork. Để đơn giản hóa mô hình, ta sẽ mặc định là các biến bias bằng 0.    Huấn luyện mạng neural: Với kiến trúc trên, biến ŷ thể hiển đầu ra của mạng sẽ được tính theo công thức:   Theo công thức trên, có thể thấy được rằng các biến weights W và bias b đóng vai trò quyết định đầu ra ŷ. Giá trị của các biến này cần được tinh chỉnh để tăng độ chính xác trong những dự đoán của mạng neural. Quá trình tinh chỉnh các biến này được gọi là quá trình huấn luyện mạng. Quá trình này là một vòng lặp gồm các bước:  Feedforward: Tính toán đầu ra ŷ Backpropagation: Cập nhật các giá trị W và bMỗi vòng lặp trong quá trình huấn luyện diễn ra như sau:   Chúng ta sẽ đi vào chi tiết từng phần Feedforward:   Code hàm feedforward:   Sau bước feedforward, ta đã tính được đầu ra ŷ của mạng neural. Tuy nhiên ta vẫn chưa xây dựng một cách thức để đánh giá mức độ đúng đắn của dự đoán này. Phương thức phổ biến nhất dùng để đánh giá mức độ chênh lệch giữa dự đoán ŷ (Giá trị output của mạng) với kết quả mong muốn y (Giá trị output thực sự mà ta muốn) là sử dụng hàm mất mát - Loss function. hàm mất mát - Loss function: Là một hàm để tính toán mức độ chênh lệch giữa ŷ và y. Vì giá trị độ chênh lệch này biểu diễn sự sai sót trong quá trình dự đoán của mạng nên giá trị này còn được gọi là giá trị lỗi. Giá trị lỗi càng nhỏ thì dự đoán của mạng neural càng chính xác. Có rất nhiều biến thể của hàm mất mát phù hợp cho từng bài toán khác nhau, trong bài viết này ta sẽ sử dụng hàm tổng bình phương lỗi (Sum of square error):   Giống như cái tên hàm tổng bình phương lỗi, giá trị lỗi được tính theo tổng bình phương của độ chệnh lệch của từng dự đoán ŷ với mong muốn y tương ứng. Mục tiêu của việc huấn luyện mạng là giảm giá trị lỗi này đến mức tối thiểu và quá trình backpropagation sẽ thực hiện điều đó. Backpropagation: Sau khi đã tính được giá trị lỗi, ta cần phải cập nhật các biến W và b sao cho các dự đoán ŷ về sau có giá trị lỗi nhỏ nhất có thể. Nhắc lại kiến thức về giải tích, để tìm cực tiểu của một hàm số ta phải tính đạo hàm của hàm số đó theo từng biến. Các giá trị đạo hàm nói cho ta biết về các “hướng” cần di chuyển các biến để hàm số đi về cực tiểu. Vì vậy, một khi ta đã có đạo hàm của hàm mất mát theo từng biến W và b, ta sẽ cập nhật các giá trị của chúng theo giá trị các đạo hàm tương ứng. Phương pháp này được gọi là gradient descent.   Để tính toán các đạo hàm của hàm mất mát theo từng biến W và b, ta sử dụng quy tắc tính đạo hàm của hàm số hợp như sau:   Code hàm Backpropagate:   Để có thể hiểu rõ hơn nữa về quá trình backpropagate và các tính toán đằng sau nó, các bạn nên xem video này:   Tổng hợp lại: Vậy là mạng neural 2 lớp đã được xây dựng xong, cũng không quá phức tạp phải không. Giờ ta sẽ chạy thử nó với một ví dụ đơn giản:   Ta có một tập hợp đầu vào X và đầu ra Y như trên. Ta sẽ bắt đầu quá trình huấn luyện với 1500 vòng lặp của các bước feedforward - backpropagate và xem biểu đồ biến thiên của hàm mất mát:   Sau khi đã học xong, với mỗi đầu vào theo thứ tự trên ta có đầu ra ŷ như sau:   Khá tốt phải không. Mỗi dự đoán ŷ đã ở rất gần so với mong muốn y rồi. Vậy là mạng neural đã được huấn luyện thành công. Hy vọng các bạn học được nhiều điều mới qua bài viết này :D. "
    }, {
    "id": 49,
    "url": "https://loda.me/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-2/",
    "title": "Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 2)",
    "body": "2019/03/07 - Chúng ta tiếp tục đi tìm hiểu xem, ở ngoài kia, trên thế giới, họ đang sử dụng Machine learning vào những sản phẩm tuyệt vời gì nhé. Nếu ai chưa xem phần 1 có thể xem tại: Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 1) #11 Style2Paints: Trí tuệ nhân tạo có khả năng nhìn ảnh vẽ và tô màu cho nó [3310 stars on Github].    #12 Tensor2Tensor: Thư viện sinh mô hình sequence to sequence trên tensorflow - Google Research [3087 stars on Github]. Bởi Ryan Sepassi tại Google Brain Paper này ra đời đã tạo một làn sóng trong giới khoa học, khi cho phép biến 1 bức ảnh bình thường trở thành tuyệt đẹp nhờ copy style của 1 bức ảnh khác. #13 Image-to-image: Mô hình chuyển đổi xuôi và ngược từ ảnh thật sang ảnh vẽ, thay đổi object trong bức ảnh, mô hình, cực kì hay.    #14 Faiss: Một thư viện mạnh mẽ cho việc tìm kiếm dữ liệu liên quan và phân nhóm vectors. [2629 stars on Github]. Thuộc Facebook Research   #15 Fashion-mnist: Một bộ dữ liệu giống MNIST nhưng nó bao gồm các sản phẩm thời trang như quần áo. [2780 stars on Github]. Bởi Han Xiao thuộc Research Scientist Zalando Tech   #16 Parl: Một framework cho việc training và evaluating AI model trên một tổ hợp rộng lớn dữ liệu về hội thoại [2578 stars - Github]. Bởi Alexander Miller thuộc Facebook Research   #17 iGAN: Model có khả năng sinh ra ảnh vẽ chỉ từ vài mô tả của người dùng. [2369 stars - Github].    #18 Deep-image-prior: Sản phẩm này cũng ấn tượng không kém, khi model có khả năng phục hồi ảnh bị xóa 1 vùng, bị nhòe trở về ảnh gốc đẹp đẽ. [2188 stars - Github]   Các mạng học sâu đang ngày càng thể hiện sức mạnh của mình trong rất nhiều lĩnh vực mà cách đây nhiều năm chưa ai nghĩ một chiếc máy tính có khả năng tư duy được như thế. Đặc biệt, qua các project mình đã giới thiệu, có thể thấy đa phần các công nghệ mới này 3/4 là đến từ các ông lớn công nghệ như Google, Facebook, v. v. . =&gt; Cho thấy học máy đang là một lĩnh vực lớn được chú trọng quan tâm nhất thời điểm hiện tại. "
    }, {
    "id": 50,
    "url": "https://loda.me/cac-open-source-ai-va-deep-learning-an-tuong-nhat-nam-2018-phan-1/",
    "title": "Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 1)",
    "body": "2019/03/07 - Trong năm vừa qua, Mybridge AI đã thống kê và so sánh trên 8,800 open source về Machine Learning để chọn ra các projects xuất sắc nhất (0. 3%) Đây là một danh sách phải đánh giá là có tính cạnh tranh cực cao, và được cân nhắc kỹ lưỡng bởi các chuyên gia. Nó bao gồm các thư viện, datasets và apps được ra mắt trong năm vừa qua. Thước đo của các project được đánh giá qua chỉ số phổ biến trong cộng đồng, mức độ tương tác, lần truy cập gần đây và ý tưởng chất, mức Star trung bình của các project trên Github là 3,558. NHỮNG CON SỐ ẤN TƯỢNG: Open source là một nguồn kiến thức dồi dào cho các kĩ sư. Bạn có thể học cách code và build những sản phẩm tuyệt vời trên nền tảng của nó. Hãy dành thời gian xem qua và chơi với các dự án Machine learning tuyệt vời này nhé. Hãy xem 1 năm qua chúng ta bỏ lỡ những gì nào! #1 Fast text: Thư viện cho text representation và classification. [11786 stars - Github] bởi Facebook Research   #2 Deep-photo-styletransfer: Code và data của paper “Deep Photo Style Transfer” [9747 stars - Github]. Bởi Fujun Luan, Ph. D. thuộc Cornell University   Paper này ra đời đã tạo một làn sóng trong giới khoa học, khi cho phép biến 1 bức ảnh bình thường trở thành tuyệt đẹp nhờ copy style của 1 bức ảnh khác. #3: API nhận diện khuôn mặt đơn giản nhất thế giới, chạy bởi Python hoặc trực tiếp trên command line. [8672 stars - Github]. Bởi Adam Geitgey   #4 Magenta: Sáng tác nhạc và ảnh nghệ thuật tự động dựa trên Trí thông minh nhân tạo. [8113 stars - Github].    #5 Sonnet: Thư viện mã nguồn mở xây dựng trên nền tensorflow, phục vụ xây dựng các mạng nơ-ron network một cách đơn giản hơn. [5731 stars - Github]. Bởi Malcolm Reynolds thuộc Deepmind (Google)   #6 deeplearn. js: Thư viện machine learning và deep learning trên nền tảng web. [5462 stars - Github]. Bởi Nikhil Thorat thuộc Google Brain   #7 Fast Style Transfer: Xây đựng trên nền tảng tensorflow [4843 stars - Github]. Bởi Logan Engstrom tại MIT. Cho phéo sinh ra một bức ảnh là kết hợp style từ 2 bức ảnh đầu vào.    #8 Pysc2: Pysc2: StarCraft II Learning Enviroment [3683 stars - Github]. Bởi Timo Ewalds thuộc DeepMind Một thư viện môi trường để ở đó trí tuệ nhân tạo chơi game StarCraft II. Và mục tiêu thắng con người.    #9 AirSim: Open source mô phỏng thế giới thực dựa trên Unreal Engine dành cho xe tự lái của Microsoft AI &amp; Research [3861 stars - Github]. Bởi Shital Shah   #10 Facets: Công cụ Visualizations dành cho dữ liệu học máy [3371 stars - Github] thuộc Google Brain   Phần 2:Các Open Source AI và Deep Learning ấn tượng nhất năm 2018 (Phần 2) "
    }, {
    "id": 51,
    "url": "https://loda.me/Nhung-ung-dung-tri-tue-nhan-tao-ai-se-thong-tri-the-gioi/",
    "title": "Top những ứng dụng trí tuệ nhân tạo sẽ thống trị thế giới",
    "body": "2019/03/07 - Trong những năm vừa qua, sự xuất hiện của Deep Learning đã giống như một bàn đạp giúp cho ngành công nghệ Trí tuệ nhân tạo (AI) đạt được rất nhiều thành tựu nổi bật. Nổi lên như một bằng chứng của Cuộc cách mạng Công nghiệp 4. 0, AI nói chung và Deep Learning nói riêng đã được ứng dụng thành công trong thực tiễn, mang lại hiệu quả vượt trội so với các phương pháp học máy truyền thống. Có thể khẳng định, Deep Learning chính là một công cụ tuyệt vời trong việc tạo ra các ứng dụng AI. Dưới đây là danh sách Top các ứng dụng Deep Learning/AI được dự đoán sẽ góp phần thay đổi thế giới trong tương lai gần:   "
    }, {
    "id": 52,
    "url": "https://loda.me/Ban-da-biet-ve-Learning-to-Learn-Linh-vuc-rat-moi-cua-Tri-tue-nhan-tao/",
    "title": "Bạn đã biết về 'Learning to Learn' - Lĩnh vực rất mới của Trí tuệ nhân tạo?",
    "body": "2019/03/07 - Trong những năm qua, lĩnh vực Trí tuệ Nhân tạo nói chung và Machine Learning nói riêng đã đạt được rất nhiều thành công nổi bật, đặc biệt là khi có sự xuất hiện của Deep Learning. Tuy vậy, vẫn tồn tại một vấn đề rất lớn mà các nhà nghiên cứu trong lĩnh vực Trí tuệ Nhân tạo phải đối mặt, đó là các thuật toán Machine Learning đòi hỏi một lượng dữ liệu dán nhãn cực lớn, Deep Learning còn đòi hỏi một lượng dữ liệu lớn hơn nhiều lần. Dữ liệu dán nhãn không luôn luôn có sẵn đối với mọi tác vụ, và chi phí để có thể thu thập một lượng dữ liệu dán nhãn đủ để có thể training các thuật toán một cách tốt nhất là rất đắt đỏ. Vì thế mà đã có nhiều nghiên cứu được thực hiện và một số phương pháp được đề xuất để phần nào đó giải quyết vấn đề nan giải này. Những phương pháp này thường được gọi là “Learning to Learn”: Transfer Learning: Trước tiên, hãy nói về Transfer Learning, một khái niệm dường như phổ biến, được nhiều người biết đến hơn. Trong hội thảo NIPS 2016, Andrew Ng đã nhận định rằng Transfer Learning, sau Supervise Learning, sẽ là động lực chính để định hướng cho sự phát triển của Machine Learning trong tương lai.   Khái niệm Transfer Learning được nhắc đến lần đầu tiên tại workshop có tên là “Learning to learn”, bàn về những phương pháp Machine Learning cho phép lưu giữ và tái sử dụng những thông tin thuật toán đã học được, trong hội thảo NIPS-95. Kể từ đó, Transfer Learning thu hút ngày càng nhiều sự chú ý. Ý tưởng chung của Transfer Learning là chia sẻ các kiến thức mà hệ thống AI đã nhận được từ quá trình training của tác vụ/domain gốc (source) sang cho một tác vụ /domain mục tiêu (target). Multitask Learning: Multitask Learning được phân chia như là một nhóm nhỏ trong Transfer Learning. Tuy vậy, không phải nhà khoa học nào cũng đồng ý với sự phân biệt này, một số coi Multitask Learning và Transfer Learning là những khái niệm tương đồng. Sự khác biệt lớn nhất ở đây là trong Transfer Learning, có sự phân biệt giữa tác vụ/domain gốc và tác vụ/domain mục tiêu. Mà trong đó, tác vụ/domain mục tiêu có vai trò quan trọng hơn. Trong Multitask Learning, các tác vụ/domain có vai trò bình đẳng hơn. Meta Learning: Meta Learning là một thuật ngữ xuất phát từ lĩnh vực Tâm lý Xã hội với định nghĩa gốc là “the process by which learners become aware of and increasingly in control of habits of perception, inquiry, learning, and growth that they have internalized”. Nói một cách ngắn gọn, Meta Learning được dùng để chỉ việc con người nhận thức và làm chủ được quá trình tiếp thu kiến thức của mình. =&gt; Learning to Learn vẫn còn là một lĩnh vực rất mới trong Trí tuệ Nhân tạo. 03 phương pháp tiếp cận được nêu trên cũng chỉ là những đại diện nổi bật nhất của Learning to Learn. Thông tin ở bài viết trên đây được tham khảo từ nguồn Tạp chí AI. "
    }, {
    "id": 53,
    "url": "https://loda.me/Chia-se-ve-Mang-no-ron-tich-chap-(Convolutional-Neural-Networks-or-ConvNEts)/",
    "title": "Chia sẻ về Mạng nơ-ron tích chập (Convolutional Neural Networks or ConvNEts)",
    "body": "2019/03/04 - Với sự phát triển phần cứng mạnh mẽ cho phép tính toán song song hàng tỉ phép tính, tạo tiền đề cho Mạng nơ-ron tích chập trở nên phổ biến và đóng vai trò quan trọng trong sự phát triển của trí tuệ nhân tạo nói chung và xử lý ảnh nói riêng. Sơ lược: Một trong các ứng dụng quan trọng của mạng nơ-ron tích chập đó là cho phép các máy tính có khả năng “nhìn” và “phân tích”. Nó được lấy cảm hứng từ vỏ não thị giác. Nôm na là Convnets (Convolutional Neural Networks) được sử dụng để nhận dạng hình ảnh bằng cách đưa nó qua mạng nơ-ron với nhiều layer, mỗi layer là các bộ lọc tích chập. Sau khi đi qua các layer này chúng ta có được đặc trưng và dùng nó nhận dạng ra đối tượng. Mỗi khi chúng ta nhìn thấy một cái gì đó, một loạt các lớp tế bào thần kinh được kích hoạt, và mỗi lớp thần kinh sẽ phát hiện một tập hợp các đặc trưng như đường thẳng, cạnh, màu sắc,v. v. v của đối tượng. lớp thần kinh càng cao sẽ phát hiện các đặc trưng phức tạp hơn để nhận ra những gì chúng ta đã thấy. Bài viết này sẽ trình bày một cách ngắn gọn về cấu tạo của Mạng nơ-ron tích chập, nói là ngắn gọn nhưng không hề ngắn ngọn chút nào… (?? :D ??) ý mình mình sẽ viết một cách đơn gián nhất để cho những bạn chỉ mới biết căn bản của học máy hay chưa từng biết gì về xử lý ảnh cũng có thể nắm bắt được tư tưởng của mạng tích chập. Chi tiết hơn cho mỗi phần mình sẽ viết cụ thể ở các bài sau. ConvNet có 02 phần chính: Lớp trích lọc đặc trưng của ảnh (Conv, Relu và Pool) và Lớp phân loại (FC và softmax).   Đầu vào (dữ liệu training):: Đầu vào của Convnets là một bức ảnh được biểu diển bởi ma trận pixel với kích thước: [w x h x d]  W: chiều rộng H: chiều cao D: Là độ sâu, hay dễ hiểu là số lớp màu của ảnh. Ví dụ ảnh RBG sẽ là 3 lớp ảnh Red, Green, Blue  Ví dụ về khái niệm channel (kênh màu) của ảnh RBG và ảnh xám Conv Layer:: Trước khi nói vào lớp conv layer, chúng ta cần biết phép tích chập là cái gì đã :v. Rất dễ thôi, bạn nhìn ảnh này:   Chúng ta có một ma trận là Kernel, khi chiếu nó lên 1 vùng của bức ảnh. Mấy từng phần tử tương ứng của ảnh, nhân nó với phần tử tương ứng của Kernel. Sau đó lấy tổng. Ta-daaaa. Mục tiêu của các lớp tích chập là trích chọn các đặc trưng của ảnh đầu vào.   Ví dụ của Conv layer. (Nguồn : CS231n notes. ) Thực chất, ở các layer đầu tiên, phép tích chập đơn giản là phép tìm biên ảnh, nếu các bạn có kiến thức cơ bản về xử lý ảnh. Còn nếu không thì bạn có thể hiểu đơn giản như này, sau khi cho qua bộ lọc thì (với 9 điểm ảnh chẳng hạn), nó sẽ lấy ra 1 diểm nổi bật nhất, làm hiện lên các đặc trưng của đối tượng trong ảnh như đường viền xung quanh đối tượng, các góc cạnh,v. v. . , và các layer tiếp theo sẽ lại trích xuất tiếp các đặc trưng của đặc trưng của các đối tượng đó, việc có nhiều layer như vậy cho phép chúng ta chia nhỏ đặc trưng của ảnh tới mức nhỏ nhất có thể. Vì thế mới gọi là mạng đặc trưng. Dưới đây là một số các khái niệm cơ bản của phần này:: Filter, Kernel hay Feature Detector đều là cách gọi của ma trận tích chập filter matrix (như mình đã đề cập ở trên), ma trận này là 1 ma trận hệ số, và quét toàn bộ bức ảnh, mỗi lần quét thì tính tích chập trên vùng bị quét. Thông thường, ở các lớp đầu tiên của ma trận này sẽ có kích thước là [5x5x3] Convolved Feature, Activation Map hay Feature Map là đầu ra của ảnh khi cho bộ lọc chạy hết bức ảnh với phép tích chập. Receptive field là vùng ảnh được chọn để tính tích chập, hay bằng đúng cái kích thước của bộ lọc. Depth là số lượng bộ lọc. Lưu ý: ở đây là số lượng bộ lọc (filter) chứ không phải số lượng kênh màu RBG như ở trên. Stride được hiểu là khoảng cách dịch chuyển của bộ lọc sau mỗi lần tính. Ví dụ khi stride=2. Tức sau khi tính xong tại 1 vùng ảnh, nó sẽ dịch sang phải 2 pixel. Tương tự với việc dịch xuống dưới Zero-Padding là việc thêm các giá trị 0 ở xung quanh biên ảnh, để đảm bảo phép tích chập được thực hiện đủ trên toàn ảnh. Vậy kích thước đầu ra của ảnh với mỗi layer được tính như thế nào?: Giả sử ảnh đầu ra là [W2 x H2 x D2] Thì:    W2 = (W1 – F + 2P) / S + 1     H2 = (H1 – F +2P) / S + 1     D2 = K  Trong đó:    [W1xH1xD1]: Kích thước ảnh đầu vào     F: Kích thước của bộ lọc Kernel (NxN)     S: giá trị Stride     P: số lượng zero-padding thêm vào viền ảnh     K: Số lượng bộ lọc (Depth)  Ví dụ: Kích thước đầu ra của lớp đầu tiên trong kiến trúc Deep Convolutional Neural Networks đã từng chiến thắng ImageNet Chanllenge 2012 là: Đầu vào: [227x227x3], W=227, F=11, S=4, P=0, and K=96. Đầu ra: (227 - 11) / 4 + 1 = 55Vậy kích thước đầu ra của layer đầu tiên là [55x55x96]. ReLU Layer:: ReLU Layer áp dụng các hàm kích hoạt (activation function) max(0,x) lên đầu ra của Conv Layer, có tác dụng đưa các giá trị âm về thành 0. Layer này không thay đổi kích thước của ảnh và không có thêm bất kì tham số nào. Mục đích của lớp ReLu là đưa ảnh một mức ngưỡng, ở đây là 0. Để loại bỏ các giá trị âm không cần thiết mà có thể sẽ ảnh hưởng cho việc tính toán ở các layer sau đó. Pool Layer:: Pool Layer thực hiện chức năng làm giảm chiều không gian của đầu vào và giảm độ phức tạp tính toán của model. Ngoài ra, Pool Layer còn giúp kiểm soát hiện tượng overffiting. Thông thường, Pool layer có nhiều hình thức khác nhau phù hợp cho nhiều bài toán, tuy nhiên Max Pooling là được sử dụng nhiều và phổ biến hơn cả, với ý tưởng cũng rất sát với thực tế: “Giữ lại chi tiết quan trọng” hay hiểu ở trong bài toán này chính giữ lại pixel có giá trị lớn nhất. Ví dụ: Max pooling với bộ lọc 2x2 và stride = 2. Bộ lọc sẽ chạy dọc ảnh. Và với mỗi vùng ảnh được chọn, sẽ chọn ra 1 giá trị lớn nhất và giữ lại.   Max pooling kernel 2x2, stride = 2. Nguồn: Wikipedia Thông thường max pooling có kích thước là 2x2 và stride=2. Nếu lấy giá trị quá lớn, thay vì giúp đỡ thì nó lại làm phá vỡ cấu trúc ảnh và mất mát thông tin nghiêm trọng (==!). Vì vậy mà một số chuyên gia không thích sử dụng layer này mà thay vào đó sử dụng thêm các lớp Conv Layer và tăng số stride lên mỗi lần. Fully_Connected Layer (FC):: Tên tiếng việt là Mạng liên kết đầy đủ. Tại lớp mạng này, mỗi một nơ-ron của layer này sẽ liên kết tới mọi nơ-ron của lớp khác. Để đưa ảnh từ các layer trước vào mạng này, buộc phải dàn phẳng bức ảnh ra thành 1 vector thay vì là mảng nhiều chiều như trước. Tại layer cuối cùng sẽ sử dụng 1 hàm kinh điển trong học máy mà bất kì ai cũng từng sử dụng đó là softmax để phân loại đối tượng dựa vào vector đặc trưng đã được tính toán của các lớp trước đó. Trên đây là tóm tắt kiến trúc cơ bản của một mạng tích chập, trên thực tế sẽ có nhiều kiến trúc phức tạp hơn rất nhiều với độ chính xác gần bằng con người. Mình sẽ viết các bài tiếp theo kĩ hơn vào từng phần và giới thiệu cho các bạn các kiến trúc mới. "
    }, {
    "id": 54,
    "url": "https://loda.me/Tro-ly-ao-van-se-la-xu-huong-cong-nghe-2019/",
    "title": "Trợ lý ảo vẫn sẽ là xu hướng công nghệ 2019",
    "body": "2019/03/03 - Những năm gần đây, Trợ lý ảo đã dần trở thành xu hướng công nghệ được đón đầu. Các “ông lớn” làng công nghệ thế giới đã cho ra đời các trợ lý ảo, được nhiều người biết đến như: Apple Siri, Google Assistant, Amazon Alexa, Microsoft Cortana. Và đương nhiên vẫn còn nhiều trợ lý ảo khác được phát triển bởi các công ty công nghệ trên thế giới, có cả Việt Nam. Trong đó có cả Viettel, nơi mình và team đang phát triển 1 trợ lý ảo. Trợ lý ảo là gì mà lại trở thành xu hướng công nghệ 2019?: Có thể hiểu đơn giản trợ lý ảo là phần mềm, công cụ được xây dựng dựa trên nền tảng trí thông minh nhân tạo (AI) và thường được các nhà phát triển công nghệ tích hợp sâu vào trong hệ điều hành với mục đích chính là hỗ trợ người dùng thiết bị dễ dàng hơn bằng chính thói quen mà người dùng thường làm trên thiết bị (như các trợ lý ảo mình liệt kê ở trên). Ưu điểm của trợ lý ảo là gì?: Khả năng nhận diện giọng nói và phân tích văn bản (Voice to Text – Text to Voice): Bằng trí thông minh nhân tạo, những trợ lý ảo có thể nhận diện giọng nói chính xác, cho phép người dùng có thể tương tác với máy tính bằng giọng nói dễ dàng. Ví dụ, trợ lý ảo Siri của Apple sẽ bắt đầu khởi chạy ngay khi bạn nói “Hey Siri” thay vì phải nhấn giữ nút Home trên iPhone, iPad, sau đó có thể tiếp tục ra lệnh cho Siri thực hiện những điều bạn muốn. Khả năng xử lý ngôn ngữ tự nhiên (Công nghệ NLP – Natual Language Process): Trợ lý ảo còn có thể xử lý ngôn ngữ và đưa ra những câu trả lời phản hồi người dùng, tạo nên sự tương tác giữa người dùng và thiết bị giống hệt cuộc nói chuyện giữa người với người. Sức mạnh tìm kiếm (Search Engine): “Đứng sau” trợ giúp cho tính năng tìm kiếm của các trợ lý ảo chính là những công cụ đình đám như Bing, Google Search, thư viện bách khoa toàn thư Wikipedia hay Wolfram Alpha. Với những kho dữ liệu khổng lồ như vậy, rõ ràng những trợ lý ảo sẽ có khả năng tìm kiếm cực kỳ mạnh mẽ cả về tốc độ lẫn sự chính xác trong kết quả tìm kiếm. Khả năng học từ người dùng: Trợ lý ảo hoàn toàn có thể thu thập dữ liệu từ các thói quen sử dụng, tìm kiếm dữ liệu của người dùng và đưa ra những gợi ý chính xác nhất, và Trợ lý ảo sẽ “học” từ thói quen người dùng và trở nên “giỏi” hơn mỗi ngày. Trợ lý ảo được thực tế hóa ở các phiên bản::  Robot Website Mobile ApplicationMô hình khái quát về việc lập trình Trợ lý ảo mà team mình đang phát triển:: Hệ thống sẽ nhận đầu vào là giọng nói hoặc văn bản. Lúc này hệ thống sẽ tiền xử lý dữ liệu, nếu là giọng nói sẽ chuyển thành văn bản để xử lý bằng công nghệ speech2text (Model này là của công ty mình tự huấn luyện). Sau đó văn bản sẽ được xử lý và trích xuất thông tin thông qua tầng xử lý ngôn ngữ. Lúc này các thông tin được trích xuất bao gồm Intent (dự định, ý định) của người dùng, Object (Đối tượng) trong câu nói đó, ngoài ra còn nhiều thông tin bổ sung khác như Location, Name, v. v. . Các thông tin này sẽ được bọn mình xử lý trên các model hoặc AIML training sẵn. Từ đó trả dữ liệu về cho người dùng. Đặc biệt, điểm mạnh của trợ lý ảo hiện nay vẫn nằm ở hệ thống Search Engine, đa phần người dùng sẽ có thiên hướng tìm kiếm và hỏi đáp. Vậy nên khi xác định Intent của người dùng là tìm kiếm, bọn mình sẽ sử dụng hệ thống SE do công ty tự phát triển để tìm kiếm các thông tin chính xác nhất và gửi kêt quả về cho người dùng. Hằng ngày team mình sẽ tối ưu Trợ lý ảo bằng các công nghệ:  Công nghệ nhận dạng và xử lý tiếng nói (Voice to text - Text to voice) Xử lý ngôn ngữ tự nhiên (Natural Language Processing) Trí tuệ nhận tạo (AI) AIMLĐây là sản phẩm Trợ lý ảo do team mình đang xây dựng:   Công việc của một lập trình viên làm Trợ lý ảo với mình rất thú vị. Tuy nhiên mình cũng nhận được nhiều câu hỏi rằng Trợ lý ảo rất phát triển và là xu hướng Công nghệ mới nhưng là ở nước rất phát triển, không phải ở Việt Nam. Vậy theo mọi người, Cơ hội và thách thức cho các nhà phát triển, kỹ sư lập trình Trợ lý ảo tại Việt Nam là gì? Đây có thực sự là cơ hội mới cho các lập trình viên? Một vài số liệu thú vị về trợ lý ảo: Số lượng thiết bị thông minh được tích hợp tính năng trợ lý ảo sẽ vượt mốc 7,5 tỷ vào năm 2021, cao hơn dân số toàn cầu hiện nay. Dự kiến tới năm 2021, 47,6% thiết bị sử dụng trợ lý ảo thông qua giọng nói sẽ xuất hiện tại châu Á và châu Đại Dương. Các nền tảng trợ lý ảo đến từ Trung Quốc như Baidu, iFlytek…sẽ được sử dụng trên khoảng 43 triệu thiết bị, đi theo xu hướng tiếp tục tăng trưởng mạnh mẽ (Theo nghiên cứu và nhận định từ Ovum). "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});


    
function lunr_search(term) {
    $('#lunrsearchresults').show( 1000 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>




<form class="bd-search hidden-sm-down" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
<input type="text" class="form-control text-small"  id="lunrsearch" name="q" value="" placeholder="Type keyword and enter..."> 
</form>
            </ul>
        </div>
    </div>
    </nav>

    <!-- Search Results -->
    <div id="lunrsearchresults">
        <ul class="mb-0"></ul>
    </div>

    <!-- Content -->
    <main role="main" class="site-content">
        






<script type="application/ld+json">
{
	"@context": "https://schema.org",
	"@type": "NewsArticle",
	"mainEntityOfPage": {
	"@type": "WebPage",
	"@id": "https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/"
	},
	"headline": "「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java",
	"image": [
	"https://loda.me/assets/images/loda1553050622971/1.jpg"
	],
	"datePublished": "2019-04-06 05:28:36 +0000",
	"dateModified": "2019-04-06 05:28:36 +0000",
	"author": {
		"@type": "Person",
		"name": "loda"
	},
	"publisher": {
		"@type": "Organization",
		"name": "loda.me",
		"logo":{
			"@type":"ImageObject",
			"url":"https://loda.me/assets/images/loda.png"
		}
	},
	"description": "Hướng dẫn các bạn sử dụng biến, các kiểu dữ liệu trong java",
	"aggregateRating": {
		"@type": "AggregateRating",
		"ratingValue": "90",
		"bestRating": "100",
		"ratingCount": "2"
	}
}
</script>
<div class="container">
<div class="jumbotron jumbotron-fluid mb-3 pl-0 pt-0 pb-0 bg-white position-relative">
		<div class="h-100 tofront">
			<div class="row  justify-content-between ">
				<div class=" col-md-6  pr-0 pr-md-4 pt-4 pb-4 align-self-center">
					<p class="text-uppercase font-weight-bold">
                        <span class="catlist">
						
                          <a class="sscroll text-danger" href="/categories.html#java">java</a><span class="sep">, </span>
                        
                          <a class="sscroll text-danger" href="/categories.html#java basic">java basic</a><span class="sep">, </span>
                        
                          <a class="sscroll text-danger" href="/categories.html#series 2 tuần">series 2 tuần</a><span class="sep">, </span>
                        
                          <a class="sscroll text-danger" href="/categories.html#kiểu dữ liệu java">kiểu dữ liệu java</a><span class="sep">, </span>
                        
                        </span>
					</p>
					<h1 class="display-4 mb-4 article-headline">「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java</h1>
					<div class="d-flex align-items-center">
                        
                        <img class="rounded-circle" src="/assets/images/loda.jpg" alt="loda" width="70"/>
                        
						<small class="ml-3"> loda <span><a target="_blank" href="https://www.facebook.com/loda.mee" class="btn btn-outline-success btn-sm btn-round ml-1">Follow</a></span>
                            <span class="text-muted d-block mt-1">Mar 20, 2019 · <span class="reading-time">
  
  
    13 mins read
  
</span>
    </span>
						</small>
					</div>
				</div>
                
				<div class="col-md-6 pr-0 align-self-center">
					<img class="rounded" src="/assets/images/loda1553050622971/1.jpg" alt="「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java">
				</div>
                
			</div>
		</div>
	</div>
</div>





<div class="container-lg pt-4 pb-4">
	<div class="row justify-content-center">
        
        
        <!-- Share -->
		<div class="col-lg-2 pr-4 mb-4 col-md-12">
			<div class="sticky-top sticky-top-offset text-center">
				<div class="share">
    <p>
        Share
    </p>
    <ul>
        <li class="ml-1 mr-1">
        <a target="_blank" href="https://twitter.com/intent/tweet?text=「Java basic #2」Biến, phạm vi, kiểu dữ liệu, toán tử trong Java&url=https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        <i class="fab fa-twitter"></i>
        </a>
        </li>
        
        <li class="ml-1 mr-1">
        <a target="_blank" href="https://facebook.com/sharer.php?u=https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
        <i class="fab fa-facebook-f"></i>
        </a>
        </li>
        
        <li class="ml-1 mr-1">
        <a target="_blank" href="https://plus.google.com/share?url=https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" onclick="window.open(this.href, 'facebook-google', 'width=550,height=435');return false;">
        <i class="fab fa-google"></i>
        </a>
        </li>
        
    </ul>
    
    <div class="sep">
    </div>				
    <ul>
        <li> 
        <a  class="small smoothscroll" href="#disqus_thread"></a>
        </li>
    </ul>
    
</div>
			</div>
		</div>
        
        
		<div class="col-md-12 col-lg-8">
            
            <!-- Article -->
			<article class="article-post">                
			<p>Hế luuuuu everyone, lại là mình <code class="highlighter-rouge">Loda</code> đây, chào mừng các bạn quay trở lại với series <strong>Thành thạo Java Basic trong 2 tuần.</strong>. Trong bài ngày hôm nay, chúng ta sẽ học về <strong>Biến</strong>, <strong>Kiểu dữ liệu</strong> và một số các <strong>Toán tử</strong> trong <code class="highlighter-rouge">Java</code> nhé các bạn. Bài này sẽ khá nhiều ví dụ và kiến thức nên chúng ta vào bài luôn hah.</p>

<h4 id="biến--kiểu-dữ-liệu">Biến &amp; Kiểu dữ liệu</h4>

<p>Chúng ta sẽ chạy một ví dụ trước rồi đi vào chi tiết nhé. Các bạn tạo một project mới, đặt tên là <code class="highlighter-rouge">Bài 2</code> hay gì cũng được, tuỳ bạn chọn nhé. Và tạo cho mình một file là <code class="highlighter-rouge">Calculation.java</code> như hình.</p>

<p><img src="/assets/images/loda1553050622971/2.jpg" alt="image-title-here" class="center-image" /></p>

<p>Sau đó các bạn viết code như này và chạy thử:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculation</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="c1">// khai bao so nguyen</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">5</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Các bạn chạy chương trình này (click chuột phải vào file <code class="highlighter-rouge">Calculation &gt; Run Main()</code>). sẽ thấy hiện kết quả là <code class="highlighter-rouge">c = 15</code>;</p>

<p>Nhìn code thì rất dễ hiểu phải không, tuy nhiên chúng ta cùng lí giải chi tiết để hiểu hơn về <code class="highlighter-rouge">Biến</code> và <code class="highlighter-rouge">Kiểu dữ liệu</code> trong <code class="highlighter-rouge">Java</code>.</p>

<p>Thứ nhất là cái <code class="highlighter-rouge">// khai bao so nguyen</code>, cái này gọi là <code class="highlighter-rouge">Comment</code>, tức các bạn viết gì sau 2 cái dấu <code class="highlighter-rouge">//</code> thì nó sẽ không ảnh hưởng tới <code class="highlighter-rouge">code</code> của chương trình, nó chỉ mang ý nghĩa chú thích thôi.</p>

<p>Thứ hai là cái này:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
</code></pre></div></div>

<p>Nói về <code class="highlighter-rouge">Biến</code> (<code class="highlighter-rouge">Variable</code>) các bạn có liên tưởng tới liên tưởng tới biến <code class="highlighter-rouge">x</code> trong đồ thị hàm số <code class="highlighter-rouge">ax + b = 0</code> không 😂 Thì chính là nó đấy.</p>

<blockquote>
  <p><code class="highlighter-rouge">Biến</code> sẽ giúp chúng ta lưu trữ và quản lý các giá trị trong chương trình.</p>
</blockquote>

<p>Trong <code class="highlighter-rouge">Java</code>, <code class="highlighter-rouge">Biến</code> cũng là đại diện cho một đối tượng và đối tượng này phải được xác định là thuộc <code class="highlighter-rouge">Kiểu dữ liệu</code> nào. Sẽ giống với phương trình <code class="highlighter-rouge">x</code> kia, nhưng đề bài phải ghi rõ <code class="highlighter-rouge">x</code> là số nguyên, số thực hay số phức để người làm bài người ta còn biết.</p>

<p>Có các kiểu dữ liệu <code class="highlighter-rouge">nguyên thuỷ</code> (<code class="highlighter-rouge">primitive</code>) như sau:</p>

<ul>
  <li><code class="highlighter-rouge">boolean</code>: là kiểu logic, chỉ có 2 giá trị <code class="highlighter-rouge">true</code> hoặc <code class="highlighter-rouge">false</code></li>
  <li><code class="highlighter-rouge">char</code>: kiểu ký tự, chỉ chứa đc được một ký tự, được định nghĩa trong dấu ngoặc đơn <code class="highlighter-rouge">'</code></li>
  <li><code class="highlighter-rouge">int</code> : số nguyên (<code class="highlighter-rouge">1,2,3, ..</code>)</li>
  <li><code class="highlighter-rouge">long</code>: số nguyên, lớn hơn <code class="highlighter-rouge">int</code>. (sẽ giải thích ở dưới)</li>
  <li><code class="highlighter-rouge">float</code>: số thực (<code class="highlighter-rouge">1.5, 2.5, ..</code>).</li>
  <li><code class="highlighter-rouge">double</code>: số thực, lớn hơn <code class="highlighter-rouge">float</code>.</li>
</ul>

<p>Ngoài ra còn 2 kiểu dữ liệu nhỏ hơn <code class="highlighter-rouge">int</code> là <code class="highlighter-rouge">byte</code> và <code class="highlighter-rouge">short</code>. Thì mình sẽ nói sau hah. Còn trước mắt tập trung vào các nhóm chính kia đã.</p>

<p>Tiếp đến là kiểu dữ liệu cao cấp hơn gọi là <code class="highlighter-rouge">Object</code> mà đặc trưng nhất là <code class="highlighter-rouge">String</code>.</p>

<ul>
  <li><code class="highlighter-rouge">String</code>: Một chuỗi các ký tự, được định nghĩa trong dấu ngoặc kép <code class="highlighter-rouge">""</code>. vd <code class="highlighter-rouge">String a = "Hellooo world~~~"</code> (Nhớ tới ví dụ ở <a href="http://loda.me/Java-basic-1-Gioi-thieu-Java-Cai-dat-moi-truong-va-Hellooo-world/"><code class="highlighter-rouge">Bài #1</code></a> hem các bạn)</li>
</ul>

<p>Mọi loại dữ liệu đều có một cái gọi là <code class="highlighter-rouge">Giá trị mặc định</code>, khi các bạn không cung cấp cho nó giá trị, nó sẽ tự có 1 giá trị mặc định.</p>

<div style="text-align: center;">
    <table align="center" border="1" cellpadding="5" cellspacing="1" style="border-collapse:collapse">
        <tbody>
            <tr>
                <th style="text-align:left; width:30%">Kiểu dữ liệu</th>
                <th style="text-align:left; width:30%">Giá trị mặc định</th>
                <th style="text-align:left">Kích thước</th>
            </tr>
            <tr>
                <td>boolean</td>
                <td>false</td>
                <td>1 bit</td>
            </tr>
            <tr>
                <td>char</td>
                <td>'\u0000'</td>
                <td>2 byte</td>
            </tr>
            <tr>
                <td>byte</td>
                <td>0</td>
                <td>1 byte</td>
            </tr>
            <tr>
                <td>short</td>
                <td>0</td>
                <td>2 byte</td>
            </tr>
            <tr>
                <td>int</td>
                <td>0</td>
                <td>4 byte</td>
            </tr>
            <tr>
                <td>long</td>
                <td>0L</td>
                <td>8 byte</td>
            </tr>
            <tr>
                <td>float</td>
                <td>0.0f</td>
                <td>4 byte</td>
            </tr>
            <tr>
                <td>double</td>
                <td>0.0d</td>
                <td>8 byte</td>
            </tr>
            <tr>
                <td>String</td>
                <td>null</td>
                <td></td>
            </tr>
        </tbody>
    </table>
</div>

<p>Ở đây bạn sẽ thấy có chữ <code class="highlighter-rouge">L</code> <code class="highlighter-rouge">f</code> <code class="highlighter-rouge">d</code> sau số <code class="highlighter-rouge">0</code>. Đó là những ký tự đánh dấu cho Java phân biệt là số <code class="highlighter-rouge">0L</code> là số 0 nhưng dạng <code class="highlighter-rouge">long</code>, <code class="highlighter-rouge">f</code> là dạng <code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">d</code> là <code class="highlighter-rouge">double</code>.</p>

<h4 id="cách-khai-báo">Cách khai báo</h4>

<p>Để khai báo biến, bắt buộc trước đó bạn phải chỉ cho nó <code class="highlighter-rouge">kiểu dữ liệu</code> mà nó sẽ nhận, ngoài ra có thể có giá trị hoặc không.</p>

<ul>
  <li>Cách 1: <code class="highlighter-rouge">[kiểu_dữ_liệu][tên_biến];</code></li>
  <li>Cách 2: <code class="highlighter-rouge">[kiểu_dữ_liệu][tên_biến] = [giá_trị];</code></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">;</span> <span class="c1">// Khai báo 3 biến có kiểu dữ liệu int</span>
<span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">4.5f</span><span class="o">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">4</span><span class="n">f</span><span class="o">;</span> <span class="c1">// Khai báo 2 biến có kiểu dữ liệu float với giá trị ban đầu. ở đây biến `c` sẽ được hiểu là c = 4.0</span>
<span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">4444.3</span><span class="o">;</span>
<span class="kt">char</span> <span class="n">t</span> <span class="o">=</span> <span class="sc">'c'</span><span class="o">;</span>
<span class="n">String</span> <span class="n">e</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="o">;</span>

</code></pre></div></div>
<h4 id="cách-đặt-tên">Cách đặt tên</h4>

<p>Trong <code class="highlighter-rouge">Java</code>, tuy không bắt buộc, nhưng chúng ta luôn thống nhất với nhau cách đặt tên biến theo một nguyên tắc, để đảm bảo khi đọc <code class="highlighter-rouge">code</code> sẽ có tính nhất quán và chuẩn chỉnh.</p>

<ul>
  <li>Tên biến phải tuân theo <code class="highlighter-rouge">quy tắc lạc đà (Camel Case)</code>: đó là chữ cái đầu tiên của từ đầu tiên phải viết thường và chữ cái đầu tiên của các từ tiếp theo phải viết hoa, ví dụ: <code class="highlighter-rouge">listStudent</code>, <code class="highlighter-rouge">minScore</code>.</li>
</ul>

<p>Chi tiết các bạn xem <a href="https://www.oracle.com/technetwork/java/codeconventions-135099.html">ở đây</a> nhé, nói ra khá dài, nhưng nắm được cái ý ở trên của mình là cũng khá ổn r.</p>

<h4 id="phạm-vi-sử-dụng">Phạm vi sử dụng</h4>

<p>Một khi bạn đã khai báo biến, thì bạn có thể sử dụng nó trong những <code class="highlighter-rouge">Phạm vi</code> mà nó khả dụng. ?? 😀?? Cùng nhìn ví dụ ở dưới nhé.</p>

<p>Ví dụ:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
    <span class="c1">// khai bao so nguyen `a`</span>
    <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
    <span class="c1">// Gán giá trị cho a, bạn sử dụng toán tử `=`</span>
    <span class="c1">// Sử dụng biến a bình thường</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">124214</span><span class="o">;</span>


    <span class="c1">// lấy a và cộng thêm 1,, rồi gán ngược lại giá trị đó vào a :D</span>
    <span class="c1">// Sử dụng biến a bình thường</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

<span class="o">}</span>
<span class="c1">// Gán lại giá trị cho a = 100 - 10;</span>
<span class="c1">// Chương trình lỗi</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">10</span><span class="o">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Phạm vi</code> (<code class="highlighter-rouge">Scope</code>) là đây các bạn ạ, chính là 2 cái dấu <code class="highlighter-rouge">{}</code>, khi bạn khai báo một biến <code class="highlighter-rouge">a</code> trong 2 cái dấu <code class="highlighter-rouge">{</code> <code class="highlighter-rouge">}</code> thì bạn chỉ có thể sử dụng ở trong nó thôi, ra ngoài nó sẽ không hiểu <code class="highlighter-rouge">a</code> là thằng nào và từ đâu chui ra.</p>

<blockquote>
  <p><code class="highlighter-rouge">Biến</code> không thể sử dụng ngoài, nhưng nó có thể được sử dụng ở bên trong những <code class="highlighter-rouge">scope</code> mà nó chứa hoặc cùng cấp với nó.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculation</span><span class="o">{</span>
    <span class="c1">// Khai báo a ở ngoài main, cái `public static` là cần thiết nhé, còn chi tiết thì chúng ta sẽ học ở các bài sau.</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="c1">// thay đổi a, ở trong, vẫn okie.</span>
        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>

        <span class="c1">// Biến a có thể sử dụng trong các `scope` con của nó</span>
        <span class="c1">// Làm gì biến a ở đây cũng được, biến đổi nó.</span>

        <span class="c1">// gán giá trị biến a vào b;</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="toán-tử">Toán tử</h4>

<p>Khi đã xác định các <code class="highlighter-rouge">Biến</code> trong chương trình, bạn có thể sử dụng <code class="highlighter-rouge">toán tử</code> để thay đổi các giá trị. Các <code class="highlighter-rouge">toán tử</code> thì khá đơn giản, giống môn toán bình thường thôi. Với các kiểu <code class="highlighter-rouge">nguyên thuỷ (primitive)</code> ta có:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculation</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">a</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// c = 0 + 5 cộng</span>
      <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// d = 0 - 5 trừ</span>
      <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">5</span><span class="o">;</span> <span class="c1">// f = 0 x 5 nhân</span>
      <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="mi">5</span><span class="o">;</span> <span class="c1">// g = 0 : 5; chia</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Còn với <code class="highlighter-rouge">String</code> thì bạn có thể sử dụng <code class="highlighter-rouge">+</code> để ghép 2 chuỗi mà thôi. Còn các toàn tử còn lại không được sử dụng với <code class="highlighter-rouge">String</code></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculation</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
      <span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"Hello"</span>
      <span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="s">"World"</span>
      <span class="c1">// Mình đã nối 3 xâu là "Hello" + " " (Khoảng trắng) + "World" lại với nhau</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">b</span><span class="o">);</span>

      <span class="n">String</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">5</span><span class="o">;</span> <span class="c1">// String cộng với một số nguyên?</span>
      <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">c</span><span class="o">);</span> <span class="c1">// Kết quả sẽ là: "Hello 5" :V</span>
      <span class="c1">// Bạn sẽ hiểu là khi cộng String với một số, số đó sẽ bị chuyển thành String và nối vào sau.</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ở trên có một ví dụ về việc cộng một <code class="highlighter-rouge">String</code> với <code class="highlighter-rouge">int</code>. Rất kì lạ phải không, 2 <code class="highlighter-rouge">kiểu dữ liệu</code> khác nhau khi tính toán với nhau thì sẽ được <code class="highlighter-rouge">Java</code> xử lý bằng cách <code class="highlighter-rouge">Ép kiểu</code>.</p>

<h4 id="ép-kiểu-dữ-liệu">Ép kiểu dữ liệu</h4>

<p>Nhìn vào ví dụ sau, bạn sẽ rõ.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Calculation</span><span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
      <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
      <span class="kt">float</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">3.5f</span><span class="o">;</span> <span class="c1">// dùng chữ f để nó hiểu đây là 3,5 float chứ k phải 3,5 double</span>

      <span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// c = 5.5</span>

      <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// báo lỗi. Vì sao?</span>
      <span class="c1">// vì java đang hiểu 2 + 3.5 nó sẽ ép thành 5.5 là float. Bây giờ gán nó vào số nguyên thì sẽ như này int = float?</span>

      <span class="c1">// Để gán được bạn cần sử dụng ép kiểu</span>
      <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span> <span class="c1">// d = 5</span>
      <span class="c1">// a + b = 5.5 =&gt; ép thành (int) =&gt; 5 (lấy phần nguyên thôi)</span>

      <span class="kt">char</span> <span class="n">character</span> <span class="o">=</span> <span class="sc">'5'</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">character</span><span class="o">;</span> <span class="c1">// number = 53. Why?</span>

      <span class="c1">// Vì ép `char` thành `int` thì nó sẽ không chuyển chữ thành số, mà nó sẽ kiếm tra '5' là ký tự ASCII thứ bao nhiêu trong máy tính, và trả lại số thứ tự đó.</span>

      <span class="kt">float</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span> <span class="mi">5</span><span class="o">;</span> <span class="c1">// =&gt; 5.0</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Tới đây là các bạn đã có thể sử dụng được <code class="highlighter-rouge">Biến</code> trong <code class="highlighter-rouge">Java</code> rồi đó, có thể sử dụng làm bài tập được rồi kakakakaka :D, còn phần dưới đây mình sẽ nói thêm về bản chất của <code class="highlighter-rouge">Biến</code> và giới hạn giá trị của nó.</p>

<h4 id="bản-chất-của-biến-nói-thêm">Bản chất của biến (Nói thêm)</h4>

<p>Khi các bạn khai báo một biến <code class="highlighter-rouge">int</code> trong chương trình của mình và sử dụng lung tung khắp mọi nơi, thì bạn có biết cái biến <code class="highlighter-rouge">int</code> ý ở đâu lòi ra không :))</p>

<p>Về bản chất, <code class="highlighter-rouge">Biến</code> sẽ là một vùng nhớ trong thiết bị vật lý mà dễ nhất là để trong <code class="highlighter-rouge">ram</code>. và khi bạn cho nó một giá trị, nó sẽ lưu trữ số đó vào <code class="highlighter-rouge">ram</code>, và cần thì lấy lên.</p>

<p><img src="/assets/images/loda1553050622971/3.jpg" alt="image-title-here" class="center-image" /></p>

<p>Vậy để <code class="highlighter-rouge">ram</code> biết bạn muốn lưu cái gì thì bạn phải khai báo cho nó. Ví dụ bạn bảo tôi cần một số nguyên <code class="highlighter-rouge">int</code>. Thì máy tính hiểu là mình cần lưu trữ một số nguyên bình thường, không quá lớn, nó sẽ cho bạn <code class="highlighter-rouge">4 byte</code> trong <code class="highlighter-rouge">Ram</code> thích lưu gì thì lưu. nhưng <code class="highlighter-rouge">không được vượt quá 4 byte</code>.</p>

<blockquote>
  <p><code class="highlighter-rouge">4 byte = 32 bit</code>, bỏ đi 1 bit đầu tiên để đánh dấu là số âm hay dương, thì còn <code class="highlighter-rouge">31 bit</code> =&gt; số lớn nhất mà biến int lưu trữ được là <code class="highlighter-rouge">2^31 - 1</code> = <code class="highlighter-rouge">2147483647</code></p>
</blockquote>

<p>Từ đây, bạn sẽ hiểu vì sao có số <code class="highlighter-rouge">long</code>, vì nhu cầu lưu số lớn hơn thì <code class="highlighter-rouge">long</code> được cấp tận <code class="highlighter-rouge">8 byte</code>.</p>

<p>Còn trường hợp đặc biệt như <code class="highlighter-rouge">String</code> thì tuỳ giá trị của nó có bao nhiêu ký tự, mà <code class="highlighter-rouge">Ram</code> sẽ cấp tương ứng bấy nhiêu <code class="highlighter-rouge">byte</code></p>

<h4 id="lời-kết">Lời kết</h4>

<p>hết rồi kaka 😄Ở các bài sau mình sẽ vừa đi vừa nói lại những phần còn thiếu trong <code class="highlighter-rouge">Biến</code> này nên các bạn chớ lo nhé. Chúc các bạn học tập tốt.</p>

<p>Nhớ like và chia sẻ cho bạn bè nhé ahehe/</p>

                
			</article>
			
			<!-- Your like button code -->
<div
  class="fb-like"
  data-href="https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/"
  data-layout="standard"
  data-action="like"
  data-show-faces="true"
></div><br>
<div class="fb-share-button" 
data-href="https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" 
data-layout="button"
  data-size="small">
  <a target="_blank"
    href="https://www.facebook.com/sharer/sharer.php?u=https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/&amp;src=sdkpreparse"
    class="fb-xfbml-parse-ignore">Chia sẻ</a>
</div>
             
            
             <!-- Author Box -->
                				
				<div class="row mt-5">
					<div class="col-md-2 align-self-center">
                         
                        <img class="rounded-circle" src="/assets/images/loda.jpg" alt="loda" width="90"/>
                         
					</div>
					<div class="col-md-10">		
                        <h5 class="font-weight-bold">Written by loda <span><a target="_blank" href="https://www.facebook.com/loda.mee" class="btn btn-outline-success btn-sm btn-round ml-2">Follow</a></span></h5>
						Là chàng coder :'( yêu màu tím , thích màu hồng, sống nội tâm, hay khóc thầm, ghét sự giả dối... Mong muốn chia sẻ cho cộng đồng các kiến thức mới về lâp trình nói chung và đời sống nói riêng.					
					</div>
				</div>				
				
            
            <!-- Comments -->
            
                <!--  Don't edit anything here. Set your disqus id in _config.yml -->

<div id="comments" class="mt-5">
    <!-- <div id="disqus_thread">
    </div>
    <script type="text/javascript">
        var disqus_shortname = 'loda-me'; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript> -->
    <div 
        class="fb-comments" 
        data-width="100%"
        data-href="https://loda.me/Java-basic-2-Bien-pham-vi-kieu-du-lieu-toan-tu-trong-java/" 
        data-numposts="5">
    </div>
</div>
            
            
		</div>
        
        
	</div>
</div>

<!-- Aletbar Prev/Next -->
<div class="alertbar" class="display:block">
	<div class="container">
		<div class="row prevnextlinks small font-weight-bold">
			
			<div class="col-md-6 rightborder pl-0">
				<a class="text-dark" href="/Java-basic-1-Gioi-thieu-Java-Cai-dat-moi-truong-va-Hellooo-world/"> <img height="30px" class="mr-1" src="/assets/images/loda1553005203072/1.jpg">  「Java basic #1」Giới thiệu Java, Cài đặt môi trường và Hellooo world~</a>
			</div>
			
			
			<div class="col-md-6 text-right pr-0">
				<a class="text-dark" href="/Java-basic-3-Ham-va-cau-lenh-dieu-kien/"> 「Java basic #3」Hàm và câu lệnh điều kiện  <img height="30px" class="ml-1" src="/assets/images/loda1553158182446/1.jpg"> </a>
			</div>
			
		</div>
	</div>
</div>
					
    </main>


    <!-- Scripts: popper, bootstrap, theme, lunr -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

    <script src="/assets/js/bootstrap.min.js" ></script>

    <script src="/assets/js/theme.js"></script>


    <!-- Footer -->
    <footer class="bg-white border-top p-3 text-muted small">
        <div class="container">
        <div class="row align-items-center justify-content-between">
            <div>
                
                <div>
                        <div>
                            <span class="navbar-brand mr-2 mb-0"
                                style="    padding-bottom: 0rem;     padding-top: 0.68rem;"><strong>Loda</strong></span>
                            <span>Copyright ©
                                <script>document.write(new Date().getFullYear())</script>.</span>
                        </div>
                </div>

                <!--  Github Repo Star Btn-->
                <!-- <a class="text-dark ml-1" target="_blank" href="https://github.com/loda-kun/loda-kun.github.io"><i class="fab fa-github"></i> Fork on Github</a> -->
               
                <div class="sticky-top sticky-top-80">
                    <p>Chia sẻ, hướng dẫn lập trình miễn phí và chất lượng nhất.</p>
                    <p>
                      Cảm ơn bạn đã theo dõi <a class="text-danger">Loda</a>, ủng hộ của bạn kèm
                      theo phản hồi sẽ giúp loda cải thiện thêm chất lượng bài viết.
                    </p>
                </div>

            </div>
            <div class="fb-page" data-href="https://www.facebook.com/loda.mee/" data-small-header="true"
                data-adapt-container-width="true" data-hide-cover="false" data-show-facepile="true">
                <blockquote cite="https://www.facebook.com/loda.mee/" class="fb-xfbml-parse-ignore"><a
                        href="https://www.facebook.com/loda.mee/">Loda</a></blockquote>
            </div>
        </div>
        </div>
    </footer>

    <!-- All this area goes before </body> closing tag --> 
<div class="footer-tracking" style="font-size:15px">
    <ul class="d-flex align-items-center justify-content-center list-unstyled m-0">
        <li class="item-footer px-3">
            <a href="/privacy-policy">PRIVACY POLICY</a>
        </li>
        <li class="item-footer px-3 m-0">
            <a href="/about">ABOUT</a>
        </li>
        <li class="item-footer px-3 m-0">
            <a href="/contact">CONTACT</a>
        </li>
    </ul>
</div>
<div class="footer-tracking text-center">
    <p style="font-size:12px">
        Made with <a target="_blank" href="https://www.wowthemes.net/mundana-jekyll-theme/"> Mundana Theme </a> by <a
            target="_blank" href="https://www.wowthemes.net">WowThemes</a>
        and images was <a href="http://www.freepik.com">Designed by Freepik</a>
    </p>
</div>
    <script
  type="text/javascript"
  src="//downloads.mailchimp.com/js/signup-forms/popup/unique-methods/embed.js"
  data-dojo-config="usePlainJson: true, isDebug: false"
></script>
<script type="text/javascript">
  window.dojoRequire(["mojo/signup-forms/Loader"], function(L) {
    L.start({
      baseUrl: "mc.us20.list-manage.com",
      uuid: "78b78b7108a5c924d4d147cd0",
      lid: "9435c8836b",
      uniqueMethods: true
    });
  });
</script>



</body>

</html>
